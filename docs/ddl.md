`ddl` is a package that can read `sq` tables and generate the DDL commands needed to construct them.

Table and column attributes can be defined on a table struct either via **struct tags** or the **`DDLer` interface** (or both).

`ddl` does not handle the setting of the table name or column name, that is handled by `sq` (see the documentation for [`sq.New`](#)).

## How are `sq` Fields mapped to SQL types?

Every Field provided by `sq` has a default SQL type, so you don't have to explicitly specify the type in the struct tag if the default is what you already want.

Any other SQL type `(e.g. INT[], TEXT[], TSVECTOR, etc)` is modeled by a `sq.CustomField`, which has no default type which means a type must be specified.

| Field | Go Type | Default SQL type |
|-------|-----|-------|
| `sq.BlobField` | `[]byte` | `BLOB` (SQLite/MySQL), `BYTEA` (Postgres) |
| `sq.BooleanField` | `bool` | `BOOLEAN` |
| `sq.NumberField` | `int, int64, float64, etc` | `INT` |
| `sq.StringField` | `string` | `TEXT` (SQLite/Postgres), `VARCHAR(255)` (MySQL) |
| `sq.TimeField` | `time.Time` | `DATETIME` (SQLite/MySQL), `TIMESTAMPTZ` (Postgres) |
| `sq.JSONField` | any JSON compatible type | `JSON` (SQLite/MySQL), `JSONB` (Postgres) |
| `sq.UUIDField` | google/uuid | `BINARY(16)` (SQLite/MySQL), `UUID` (Postgres) |
| `sq.CustomField` | - | - |

## How to use DDL Struct tags

A `ddl` struct tag consists of one or more modifiers. Modifiers are delimited by spaces.

```go
type ACTOR struct {
    sq.TableInfo
    ACTOR_ID sq.NumberField `ddl:"notnull primarykey identity"`
}
```
```sql
CREATE TABLE actor (
    actor_id INT NOT NULL PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY
);
```

<br>
Modifiers may be have values associated with them on the right hand side of an equals '=' sign. There must not be any spaces around the '=' sign, since a space would start a new modifier.

Notice how the value `DATETIME('now')` for the `default` modifier has no spaces, so no brace quoting is necessary.

```go
type ACTOR struct {
    sq.TableInfo
    LAST_UPDATE sq.TimeField `ddl:"type=TIMESTAMP notnull default=DATETIME('now')"`
}
```
```sql
CREATE TABLE actor (
    last_update TIMESTAMP NOT NULL DEFAULT (DATETIME('now'))
);
```

<br>
If a modifier value does contain spaces, the entire value has to be {brace quoted} to ensure it remains a single unit.

```go
type FILM_ACTOR struct {
    sq.TableInfo
    ACTOR_ID    sq.NumberField `ddl:"notnull references=actor.actor_id"`
    LAST_UPDATE sq.TimeField   `ddl:"notnull default={DATETIME('now', 'localtime')}"`
    //                                                               ↑
    //                                                          whitespace
}
```
```sql
CREATE TABLE film_actor (
    actor_id INT NOT NULL REFERENCES actor (actor_id)
    ,last_update DATETIME NOT NULL DEFAULT (DATETIME('now', 'localtime'))
    --                                                     ↑
    --                                                 whitespace
);
```

<br>
Values themselves may have additional modifiers. Since modifiers are delimited by spaces, values with modifiers must be {brace quoted}.

```go
type FILM_ACTOR struct {
    sq.TableInfo
    ACTOR_ID    sq.NumberField `ddl:"notnull references={actor.actor_id onupdate=cascade ondelete=restrict}"`
    LAST_UPDATE sq.TimeField   `ddl:"notnull default=CURRENT_TIMESTAMP"`
}
```
```sql
CREATE TABLE actor (
    actor_id INT NOT NULL REFERENCES actor (actor_id) ON UPDATE CASCADE ON DELETE RESTRICT
    ,last_update DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP
);
```

## Dialect-specific DDL

## Constraints and Indexes have default generated names

## DDL struct tag reference

### `type`

### `auto_increment`, `autoincrement`, `identity`, `alwaysidentity`

### `notnull`

### `onupdatecurrenttimestamp`

### `generated`

### `stored`

### `virtual` (column)

### `virtual` (table)

### `collate`

### `default`

### `primarykey`

### `primarykey.cols`

### `primarykey.deferrable`

### `primarykey.deferred`

### `primarykey.ignore`

### `references`

### `references.name`

### `references.cols`

### `references.onupdate`

### `references.ondelete`

### `references.deferrable`

### `references.deferred`

### `references.ignore`

### `unique`

### `unique.cols`

### `unique.ignore`

### `index`

### `index.cols`

### `index.unique`

### `index.using`

### `index.where`

### `index.include`

### `index.ignore`

### `ignore`

note: why aren't sequences supported? I don't think sequences are ever used explicitly, they're almost always created as an implementation side effect of using auto incremented values. If you have a need for defining sequences explicitly and would like to see it in this package, please file an issue detailing why you use them and what you want the API to look like.
