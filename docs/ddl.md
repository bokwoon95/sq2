`ddl` is a package that introspects `sq` table structs and creates them in the database. A typical user flow looks like this:

1. Define table structs corresponding to SQL tables.
2. Pass those table structs to [Migrate/AutoMigrate](#) to generate the necessary DDL needed to create those tables.

Table and column attributes can be defined either via **struct tags** or the **`DDLTable` interface** (or both).

`ddl` does not handle the setting of the table name or column name, that is handled by `sq` (see the documentation for [`sq.New`](#)).

## How do `sq` Fields map to SQL types?

Every Field provided by `sq` has a default SQL type, so you don't have to explicitly specify the type if the default is what you already want.

`sq.CustomField` is the exception, it is a catch-all field that is meant to accomodate other SQL types not mentioned here e.g. `INT[]`, `TEXT[]`, `TSVECTOR`. `sq.CustomField` has no default SQL type, therefore a type must always be specified.

| Field | Go Type | Default SQL type |
|-------|-----|-------|
| `sq.BlobField` | `[]byte` | `BLOB` (SQLite/MySQL), `BYTEA` (Postgres) |
| `sq.BooleanField` | `bool` | `BOOLEAN` |
| `sq.NumberField` | `int, int64, float64, etc` | `INT` |
| `sq.StringField` | `string` | `TEXT` (SQLite/Postgres), `VARCHAR(255)` (MySQL) |
| `sq.TimeField` | `time.Time` | `DATETIME` (SQLite/MySQL), `TIMESTAMPTZ` (Postgres) |
| `sq.JSONField` | any JSON compatible type | `JSON` (SQLite/MySQL), `JSONB` (Postgres) |
| `sq.UUIDField` | google/uuid | `BINARY(16)` (SQLite/MySQL), `UUID` (Postgres) |
| `sq.CustomField` | - | - |

## How to use DDL struct tags

A `ddl` struct tag consists of one or more modifiers. Modifiers are delimited by spaces.

```go
type ACTOR struct {
    sq.TableInfo
    ACTOR_ID sq.NumberField `ddl:"notnull primarykey identity"`
    //                            └─────┘ └────────┘ └──────┘
    //                           modifier  modifier   modifier
}
```
```sql
CREATE TABLE actor (
    actor_id INT NOT NULL GENERATED BY DEFAULT AS IDENTITY

    ,CONSTRAINT actor_actor_id_pkey PRIMARY KEY (actor_id)
);
```

<br>

Modifiers may have values associated with them on the right hand side of an equals '=' sign. No spaces are allowed around the '=' sign, since a space would start a new modifier.
Notice how the value for the `default` modifier `DATETIME('now')` has no spaces, so no {brace quoting} is necessary.

```go
type ACTOR struct {
    sq.TableInfo
    //                                modifier value               modifier value
    //                                  ┌───────┐                 ┌─────────────┐
    LAST_UPDATE sq.TimeField `ddl:"type=TIMESTAMP notnull default=DATETIME('now')"`
    //                             └────────────┘ └─────┘ └─────────────────────┘
    //                                modifier    modifier       modifier
}
```
```sql
CREATE TABLE actor (
    last_update TIMESTAMP NOT NULL DEFAULT (DATETIME('now'))
);
```

<br>

If a modifier value does contain spaces, the entire value has to be {brace quoted} to ensure it remains a single unit.

```go
type FILM_ACTOR struct {
    sq.TableInfo
    ACTOR_ID    sq.NumberField `ddl:"notnull references=actor.actor_id"`
    //                                             brace quoted because of whitespace
    //                                               ┌────────────────────────────┐
    LAST_UPDATE sq.TimeField   `ddl:"notnull default={DATETIME('now', 'localtime')}"`
    //                               └─────┘ └────────────────────────────────────┘
    //                               modifier               modifier
}
```
```sql
CREATE TABLE film_actor (
    actor_id INT NOT NULL
    ,last_update DATETIME NOT NULL DEFAULT (DATETIME('now', 'localtime'))
    --                                                     ↑
    --                                                 whitespace

    ,CONSTRAINT film_actor_actor_id_fkey FOREIGN KEY (actor_id) REFERENCES actor (actor_id)
);
```

<br>

A modifier may have additional submodifiers. Such submodifiers are always defined after an initial modifier value, which has to be provided. When submodifiers are present, brace quoting is always necessary so that submodifiers are differentiated from top-level modifiers.

```go
type FILM_ACTOR struct {
    sq.TableInfo
    //                                                   modifier value    submodifier      submodifier
    //                                                   ┌────────────┐ ┌──────────────┐ ┌───────────────┐
    ACTOR_ID    sq.NumberField `ddl:"notnull references={actor.actor_id onupdate=cascade ondelete=restrict}"`
    //                               └─────┘ └────────────────────────────────────────────────────────────┘
    //                              modifier                         modifier
    LAST_UPDATE sq.TimeField   `ddl:"notnull default=CURRENT_TIMESTAMP"`
}
```
```sql
CREATE TABLE actor (
    actor_id INT NOT NULL
    ,last_update DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP

    ,CONSTRAINT film_actor_actor_id_fkey FOREIGN KEY (actor_id) REFERENCES actor (actor_id) ON UPDATE CASCADE ON DELETE RESTRICT
);
```

For a complete list of supported modifiers, see the [struct tag reference](#).

## Dialect-specific modifiers

A modifier may be prefixed by an SQL dialect like this: `<dialect>:<modifier>`. This indicates that the modifier is only applicable for that dialect. This is used for defining table structs that work on multiple dialects at once.

The currently valid dialect prefixes are: `sqlite`, `postgres` and `mysql`.

Modifiers are evaluated left-to-right, and so putting a dialect-less modifier at the end will always override any dialect-specific modifier defined at the beginning. Therefore, always define dialect-specific modifiers after any dialect-less modifiers of the same name.

Some modifiers are already dialect-specific e.g. `auto_increment` only applies to MySQL, `identity` only applies to postgres. In such cases no dialect prefix is needed, `ddl` will automatically ignore the modifier if it is not applicable for the current dialect.

```go
type FILM struct {
    sq.TableInfo
    FILM_ID          sq.NumberField `ddl:"sqlite:type=INTEGER primarykey auto_increment identity"`
    TITLE            sq.StringField `ddl:"mysql:type=VARCHAR(50)"`
    SPECIAL_FEATURES sq.CustomField `ddl:"type=JSON postgres:type=TEXT[]"`
}
```
```sql
-- One struct maps to idiomatic tables for three different dialects

-- sqlite
CREATE TABLE film (
    film_id INTEGER PRIMARY KEY
    ,title TEXT
    ,special_features JSON
);

-- postgres
CREATE TABLE film (
    film_id INT GENERATED BY DEFAULT AS IDENTITY
    ,title TEXT
    ,special_features TEXT[]

    ,CONSTRAINT film_film_id PRIMARY KEY (film_id)
);

-- mysql
CREATE TABLE film (
    film_id INT AUTO_INCREMENT
    ,title VARCHAR(50)
    ,special_features JSON

    ,PRIMARY KEY (film_id)
);
```

## Default names for Constraints and Indexes

Constraints and indexes will have default names automatically generated for them if you do not provide one. The generated names follow [Postgres' naming convention](https://stackoverflow.com/a/4108266) of

`{tablename}_{columnname(s)}_{suffix}`

where the suffix is one of the following:
- `pkey` for a Primary Key constraint
- `key` for a Unique constraint
- `idx` for any other kind of index
- `fkey` for a Foreign key

Constraint names cannot be generated for CHECK or EXCLUDE constraints, because they involve SQL expressions and it is not possible to determine (on `ddl`'s side) what columns are participating in an expression. Therefore constraint names must always be explicitly specified for CHECK and EXCLUDE. In fact, it is impossible to define CHECK and EXCLUDE constraints using struct tags because I haven't figured out what the it should look like. They can only be defined through the [`DDLTable` interface](#).

To use a custom constraint or index name, pass it in as a value to the `primarykey`, `unique` or `index` modifier.

```go
type FILM struct {
    sq.TableInfo
    TITLE sq.StringField `ddl:"notnull index"`
    //                                   ↑
    //                             no name provided
    DESCRIPTION sq.StringField `ddl:"notnull index=lorem_ipsum_dolor_sit_amet"`
    //                                             └────────────────────────┘
    //                                                   name provided
}
```
```sql
CREATE TABLE film (
    title TEXT NOT NULL
    ,description TEXT NOT NULL
);
CREATE INDEX film_title_idx ON film (title);
--                  ↑
--          default index name
CREATE INDEX lorem_ipsum_dolor_sit_amet ON film (description);
--           └────────────────────────┘
--                custom index name
```

## How to specify multiple columns for an index or constraint?

The `primarykey`, `unique` and `index` modifiers each accept a submodifier `cols` which takes in a comma-separated list of columns participating in the constraint or index.
Usually this is not needed when the struct tag is defined on a table field, as the field would implicitly be used for `cols`. But if multiple columns are needed, the `cols` submodifier must be defined explicitly defined.
In this case, the modifier can be defined in the sq.TableInfo struct tag (although any other struct tag would also work):

```go
type FILM_ACTOR struct {
    sq.TableInfo `ddl:"index={my_multicolumn_index cols=film_id,actor_id unique}"`
    //                                 ↑                └──────────────┘
    //                          custom index name       explicit columns
    FILM_ID      sq.NumberField `ddl:"references=film.film_id"`
    ACTOR_ID     sq.NumberField `ddl:"references=actor.actor_id"`
}
```
```sql
CREATE TABLE film_actor (
    film_id INT
    ,actor_id INT

    ,CONSTRAINT film_actor_film_id_fkey FOREIGN KEY (film_id) REFERENCES film (film_id)
    ,CONSTRAINT film_actor_actor_id_fkey FOREIGN KEY (actor_di) REFERENCES actor (actor_id)
)
CREATE UNIQUE INDEX my_multicolumn_index ON film_actor (film_id, actor_id);
--                            ↑                         └───────────────┘
--                     custom index name                explicit columns
```

Notice how the index name `my_multicolumn_index` was passed in to the index modifier. If you're fine with the [default naming convention](#), you can use a period `.` in place of the name to signal that you want to use the default name.

```go
type FILM_ACTOR struct {
    sq.TableInfo `ddl:"index={. cols=film_id,actor_id unique}"`
    //                        ↑
    //                      period
    FILM_ID      sq.NumberField `ddl:"references=film.film_id"`
    ACTOR_ID     sq.NumberField `ddl:"references=actor.actor_id"`
}
```
```sql
CREATE TABLE film_actor (
    film_id INT
    ,actor_id INT

    ,CONSTRAINT film_actor_film_id_fkey FOREIGN KEY (film_id) REFERENCES film (film_id)
    ,CONSTRAINT film_actor_actor_id_fkey FOREIGN KEY (actor_di) REFERENCES actor (actor_id)
)
CREATE UNIQUE INDEX film_actor_film_id_actor_id_idx ON film_actor (film_id, actor_id);
--                                 ↑
--                        default index name
```

## DDL struct tag reference

### `type`
Value: the column type. Any value passed in is literally passed to the database.

```go
type FILM struct {
    sq.TableInfo
    TITLE       sq.StringField `ddl:"type=VARCHAR(50)"`
    LAST_UPDATE sq.TimeField   `ddl:"type={TIMESTAMP WITH TIME ZONE}"`
}
```
```sql
CREATE TABLE film (
    title VARCHAR(50)
    ,last_update TIMESTAMP WITH TIME ZONE
);
```

This is also where you can define special types like SERIAL or ENUM.

```go
type FILM struct {
    sq.TableInfo
    FILM_ID     sq.NumberField `ddl:"type=SERIAL primarykey"`
    FILM_RATING sq.StringField `ddl:"type={ENUM('G', 'PG', 'PG-13', 'R', 'NC-17')} default='G'"`
}
```
```sql
CREATE TABLE film (
    film_id SERIAL PRIMARY KEY
    ,film_rating ENUM('G', 'PG', 'PG-13', 'R', 'NC-17') DEFAULT 'G'
);
```

NOTE: if your Postgres version is 10 or higher, [you should not be using SERIAL](https://stackoverflow.com/a/55300741/3030828). Instead, use [`identity`](#).

### `auto_increment`
Value: N.A.

MySQL only. Sets the column to be `AUTO_INCREMENT`.

```go
type FILM struct {
    sq.TableInfo
    FILM_ID sq.NumberField `ddl:"primarykey auto_increment"`
}
```
```sql
CREATE TABLE film (
    film_id INT AUTO_INCREMENT

    ,PRIMARY KEY (film_id)
);
```

### `autoincrement`
Value: N.A.

SQLite only. Sets the column to be `AUTOINCREMENT`.

```go
type FILM struct {
    sq.TableInfo
    FILM_ID sq.NumberField `ddl:"type=INTEGER primarykey autoincrement"`
}
```
```sql
CREATE TABLE film (
    film_id INTEGER PRIMARY KEY AUTOINCREMENT
);
```

NOTE: SQLite's author [recommends against using AUTOINCREMENT](https://www.sqlite.org/autoinc.html) if you just need an automatically generated primary key.
Defining `INTEGER PRIMARY KEY` on a column is enough to guarantee automatically generated values, and using AUTOINCREMENT will impose additional CPU and memory load on the database.

### `identity`
Value: N.A.

Postgres only. Sets the column to be `GENERATED BY DEFAULT AS IDENTITY`.

```go
type FILM struct {
    sq.TableInfo
    FILM_ID sq.NumberField `ddl:"primarykey identity"`
}
```
```sql
CREATE TABLE film (
    film_id INT GENERATED BY DEFAULT AS IDENTITY

    ,CONSTRAINT film_film_id_pkey PRIMARY KEY (film_id)
);
```

### `alwaysidentity`
Value: N.A.

Postgres only. Sets the column to be `GENERATED ALWAYS AS IDENTITY`.

```go
type FILM struct {
    sq.TableInfo
    FILM_ID sq.NumberField `ddl:"primarykey alwaysidentity"`
}
```
```sql
CREATE TABLE film (
    film_id INT GENERATED ALWAYS AS IDENTITY

    ,CONSTRAINT film_film_id_pkey PRIMARY KEY (film_id)
);
```

### `notnull`
Value: N.A.

Sets the column to be `NOT NULL`.

```go
type ACTOR struct {
    sq.TableInfo
    FIRST_NAME sq.StringField `ddl:"type=VARCHAR(255) notnull"`
}
```
```sql
CREATE TABLE actor (
    first_name VARCHAR(255) NOT NULL
);
```

### `onupdatecurrenttimestamp`
Value: N.A.

MySQL only. Enables `ON UPDATE CURRENT_TIMESTAMP` for the column.

```go
type ACTOR struct {
    sq.TableInfo
    LAST_UPDATE sq.TimeField `ddl:"default=CURRENT_TIMESTAMP onupdatecurrenttimestamp"`
}
```
```sql
CREATE TABLE actor (
    last_update DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);
```

### `generated`
Value: the generated column expression.

Sets the column's generated expression.

```go
type ACTOR struct {
    sq.TableInfo
    FIRST_NAME sq.StringField
    LAST_NAME  sq.StringField
    FULL_NAME  sq.StringField `ddl:"generated={first_name || ' ' || last_name} virtual"`
}
```
```sql
CREATE TABLE actor (
    first_name TEXT
    ,last_name TEXT
    ,full_name TEXT GENERATED ALWAYS AS (first_name || ' ' || last_name) VIRTUAL
)
```

### `stored`
Value: N.A.

Marks the column's generated expression as STORED. It does nothing if the column does not have a generated expression.

```go
type ACTOR struct {
    sq.TableInfo
    FIRST_NAME sq.StringField
    LAST_NAME  sq.StringField
    FULL_NAME  sq.StringField `ddl:"generated={first_name || ' ' || last_name} stored"`
}
```
```sql
CREATE TABLE actor (
    first_name TEXT
    ,last_name TEXT
    ,full_name TEXT GENERATED ALWAYS AS (first_name || ' ' || last_name) STORED
)
```

### `virtual` (column)
Applies when defined on a column (i.e. not sq.TableInfo). For the other definition when defined on a table, see [`virtual`](#).

Value: N.A.

Marks the column's generated expression as VIRTUAL. It does nothing if the column does not have a generated expression.

```go
type ACTOR struct {
    sq.TableInfo
    FIRST_NAME sq.StringField
    LAST_NAME  sq.StringField
    FULL_NAME  sq.StringField `ddl:"generated={first_name || ' ' || last_name} virtual"`
}
```
```sql
CREATE TABLE actor (
    first_name TEXT
    ,last_name TEXT
    ,full_name TEXT GENERATED ALWAYS AS (first_name || ' ' || last_name) VIRTUAL
)
```

NOTE: Postgres does not support `VIRTUAL` generated columns. Even if you mark a generated columns as `virtual`, `ddl` will continue to treat the generated column as `STORED`. This restriction will be lifted if Postgres eventually supports `VIRTUAL` generated columns.

### `virtual` (table)
Applies when defined on a table (i.e. sq.TableInfo). For the other definition when defined on a column, see [`virtual`](#).

Value: The name of an SQLite virtual table module (e.g. FTS5).

SQLite only. Module arguments can be supplied after the module name (delimited by spaces). When the module specified is 'fts5' (case insensitive), the table struct columns will also be passed in as module arguments.

```go
type FILM_TEXT struct {
    sq.TableInfo `ddl:"virtual={fts5 content='film' content_rowid='film_id'}"`
    TITLE        sq.StringField
    DESCRIPTION  sq.StringField
}
```
```sql
CREATE VIRTUAL TABLE film_text USING fts5 (
    title
    ,description
    ,content='film'
    ,content_rowid='film_id'
);
```

### `collate`
Value: the column collation.

For Postgres, the column collation will always be quoted with double quotes. I do not know why this is necessary, but Postgres seems to require it. The other databases do not have this behaviour.

```go
type FILM_ACTOR_REVIEW struct {
    sq.TableInfo
    REVIEW_BODY sq.StringField `ddl:"collate=C"`
}
```
```sql
CREATE TABLE film_actor_review (
    review_body TEXT COLLATE "C"
);
```

### `default`
Value: the column default.

If the column default is anything other than a string, number, `TRUE`, `FALSE`, `CURRENT_DATE`, `CURRENT_TIME` or `CURRENT_TIMESTAMP`, it will be considered an SQL expression. For SQlite and MySQL, `ddl` will automatically wrap expressions in (brackets). This does not happen for Postgres, since Postgres does not have this restriction.

```go
type FILM struct {
    sq.TableInfo
    TITLE       sq.StringField `ddl:"default=''"`
    RENTAL_RATE sq.NumberField `ddl:"type=DECIMAL(4,2) default=4.99"`
    RATING      sq.StringField `ddl:"default='G'"`
    LAST_UPDATE sq.NumberField `ddl:"default=DATETIME('now')"`
}
```
```sql
CREATE TABLE film (
    title TEXT DEFAULT ''
    rental_rate DECIMAL(4,2) DEFAULT 4.99
    rating TEXT DEFAULT 'G'
    last_update DATETIME DEFAULT (DATETIME('now'))
);
```

### `primarykey`
Value: the name of the primary key constraint. If the name is omitted, the [default name](#) will be used instead.

```go
```
```sql
```

### `primarykey.cols`

```go
```
```sql
```

### `primarykey.deferrable`

```go
```
```sql
```

### `primarykey.deferred`

```go
```
```sql
```

### `primarykey.ignore`

```go
```
```sql
```

### `references`
Value: the name of the referenced column(s).

```go
```
```sql
```

### `references.name`
Value: the name of the foreign key constraint.

```go
```
```sql
```

### `references.cols`

```go
```
```sql
```

### `references.onupdate`

```go
```
```sql
```

### `references.ondelete`

```go
```
```sql
```

### `references.deferrable`

```go
```
```sql
```

### `references.deferred`

```go
```
```sql
```

### `references.ignore`

```go
```
```sql
```

### `unique`
Value: the name of the unique constraint.

```go
```
```sql
```

### `unique.cols`

```go
```
```sql
```

### `unique.ignore`

```go
```
```sql
```

### `index`
Value: the name of the index.

```go
```
```sql
```

### `index.cols`

```go
```
```sql
```

### `index.unique`

```go
```
```sql
```

### `index.using`

```go
```
```sql
```

### `index.where`

```go
```
```sql
```

### `index.include`

```go
```
```sql
```

### `index.ignore`

```go
```
```sql
```

### `ignore`

```go
```
```sql
```

note: why aren't sequences supported? I don't think sequences are ever used explicitly, they're almost always created as an implementation side effect of using auto incremented values. If you have a need for defining sequences explicitly and would like to see it in this package, please file an issue detailing why you use them and what you want the API to look like.
