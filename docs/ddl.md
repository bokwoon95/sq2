`ddl` is a package that can read `sq` tables and generate the DDL commands needed to construct them.

Table and column attributes can be defined on a table struct either via **struct tags** or the **`DDLTable` interface** (or both).

`ddl` does not handle the setting of the table name or column name, that is handled by `sq` (see the documentation for [`sq.New`](#)).

## How are `sq` Fields mapped to SQL types?

Every Field provided by `sq` has a default SQL type, so you don't have to explicitly specify the type if the default is what you already want.

`sq.CustomField` is a catch-all field that is meant to accomodate other SQL types not mentioned here e.g. `INT[]`, `TEXT[]`, `TSVECTOR`. `sq.CustomField` has no default SQL type, therefore a type must always be specified.

| Field | Go Type | Default SQL type |
|-------|-----|-------|
| `sq.BlobField` | `[]byte` | `BLOB` (SQLite/MySQL), `BYTEA` (Postgres) |
| `sq.BooleanField` | `bool` | `BOOLEAN` |
| `sq.NumberField` | `int, int64, float64, etc` | `INT` |
| `sq.StringField` | `string` | `TEXT` (SQLite/Postgres), `VARCHAR(255)` (MySQL) |
| `sq.TimeField` | `time.Time` | `DATETIME` (SQLite/MySQL), `TIMESTAMPTZ` (Postgres) |
| `sq.JSONField` | any JSON compatible type | `JSON` (SQLite/MySQL), `JSONB` (Postgres) |
| `sq.UUIDField` | google/uuid | `BINARY(16)` (SQLite/MySQL), `UUID` (Postgres) |
| `sq.CustomField` | - | - |

## How to use DDL struct tags

A `ddl` struct tag consists of one or more modifiers. Modifiers are delimited by spaces.

```go
type ACTOR struct {
    sq.TableInfo
    ACTOR_ID sq.NumberField `ddl:"notnull primarykey identity"`
}
```
```sql
CREATE TABLE actor (
    actor_id INT NOT NULL GENERATED BY DEFAULT AS IDENTITY

    ,CONSTRAINT actor_actor_id_pkey PRIMARY KEY (actor_id)
);
```

<br>

Modifiers may be have values associated with them on the right hand side of an equals '=' sign. No spaces are allowed around the '=' sign, since a space would start a new modifier.
Notice how the value for the `default` modifier `DATETIME('now')` has no spaces, so no brace quoting is necessary.

```go
type ACTOR struct {
    sq.TableInfo
    LAST_UPDATE sq.TimeField `ddl:"type=TIMESTAMP notnull default=DATETIME('now')"`
}
```
```sql
CREATE TABLE actor (
    last_update TIMESTAMP NOT NULL DEFAULT (DATETIME('now'))
);
```

<br>

If a modifier value does contain spaces, the entire value has to be {brace quoted} to ensure it remains a single unit.

```go
type FILM_ACTOR struct {
    sq.TableInfo
    ACTOR_ID    sq.NumberField `ddl:"notnull references=actor.actor_id"`
    LAST_UPDATE sq.TimeField   `ddl:"notnull default={DATETIME('now', 'localtime')}"`
    //                                                               ↑
    //                                                          whitespace
}
```
```sql
CREATE TABLE film_actor (
    actor_id INT NOT NULL
    ,last_update DATETIME NOT NULL DEFAULT (DATETIME('now', 'localtime'))
    --                                                     ↑
    --                                                 whitespace

    ,CONSTRAINT film_actor_actor_id_fkey FOREIGN KEY (actor_id) REFERENCES actor (actor_id)
);
```

<br>

Modifier values themselves may have additional submodifiers. Since modifiers are delimited by spaces, modifier values containing such submodifiers must always be {brace quoted} in order to differentiate between the submodifiers and the top-level modifiers.

```go
type FILM_ACTOR struct {
    sq.TableInfo
    ACTOR_ID    sq.NumberField `ddl:"notnull references={actor.actor_id onupdate=cascade ondelete=restrict}"`
    //                               └─────┘ │           └────────────┘ └──────────────┘ └───────────────┘│
    //                              modifier │           modifier value    submodifier      submodifier   │
    //                                       └────────────────────────────────────────────────────────────┘
    //                                                                  modifier
    LAST_UPDATE sq.TimeField   `ddl:"notnull default=CURRENT_TIMESTAMP"`
}
```
```sql
CREATE TABLE actor (
    actor_id INT NOT NULL
    ,last_update DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP

    ,CONSTRAINT film_actor_actor_id_fkey FOREIGN KEY (actor_id) REFERENCES actor (actor_id) ON UPDATE CASCADE ON DELETE RESTRICT
);
```

## Dialect-specific modifiers

A modifier may be prefixed by an SQL dialect like this: `<dialect>:<modifier>`. This indicates that the modifier is only applicable for that dialect. This is used for defining table structs that work on multiple dialects at once.

The currently valid dialect prefixes are: `sqlite`, `postgres` and `mysql`.

Modifiers are evaluated left-to-right, and so putting a dialect-less modifier at the end will always override any dialect-specific modifier defined at the beginning. Therefore, always define dialect-specific modifiers after any dialect-less modifiers of the same name.

Some modifiers are already dialect-specific e.g. `auto_increment` only applies to MySQL, `identity` only applies to postgres. In such cases no dialect prefix is needed, `ddl` will automatically ignore the modifier if it is not applicable for the current dialect.

```go
type FILM struct {
    sq.TableInfo
    FILM_ID          sq.NumberField `ddl:"sqlite:type=INTEGER primarykey auto_increment identity"`
    TITLE            sq.StringField `ddl:"mysql:type=VARCHAR(500)"`
    SPECIAL_FEATURES sq.CustomField `ddl:"type=JSON postgres:type=TEXT[]"`
}
```
```sql
-- sqlite
CREATE TABLE film (
    film_id INTEGER PRIMARY KEY
    ,title TEXT
    ,special_features JSON
);

-- postgres
CREATE TABLE film (
    film_id INT GENERATED BY DEFAULT AS IDENTITY
    ,title TEXT
    ,special_features TEXT[]

    ,CONSTRAINT film_film_id PRIMARY KEY (film_id)
);

-- mysql
CREATE TABLE film (
    film_id INT AUTO_INCREMENT
    ,title VARCHAR(500)
    ,special_features JSON

    ,PRIMARY KEY (film_id)
);
```

## Default names for Constraints and Indexes

Constraints and indexes will have default names automatically generated for them if you do not provide one. The names follow [Postgres' naming convention](https://stackoverflow.com/a/4108266) of

`{tablename}_{columnname(s)}_{suffix}`

where the suffix is one of the following:
- `pkey` for a Primary Key constraint
- `key` for a Unique constraint
- `idx` for any other kind of index
- `fkey` for a Foreign key

Constraint names cannot be generated for CHECK or EXCLUDE constraints, because they involve SQL expressions and it is not possible to determine (on `ddl`'s side) what columns are participating in an expression. Therefore constraint names must always be explicitly specified for CHECK and EXCLUDE. In fact, it is impossible to define CHECK and EXCLUDE constraints using struct tags because I haven't figured out what the it should look like. They can only be defined through the [`DDLTable` interface](#).

To use a custom constraint or index name, pass it in as a value to the `primarykey`, `unique` or `index` modifier.

```go
type FILM struct {
    sq.TableInfo
    TITLE sq.StringField `ddl:"notnull index"`
    //                                   ↑
    //                             no name provided
    DESCRIPTION sq.StringField `ddl:"notnull index=lorem_ipsum_dolor_sit_amet"`
    //                                             └────────────────────────┘
    //                                                   name provided
}
```
```sql
CREATE TABLE film (
    title TEXT NOT NULL
    ,description TEXT NOT NULL
);
CREATE INDEX film_title_idx ON film (title);
--                  ↑
--          default index name
CREATE INDEX lorem_ipsum_dolor_sit_amet ON film (description);
--           └────────────────────────┘
--                custom index name
```

## How to specify multiple columns for an index or constraint?

The `primarykey`, `unique` and `index` modifiers each accept a submodifier `cols` which takes in a comma-separated list of columns participating in the constraint or index. By default this submodifier is not provided, so the column that the modifier is defined on is used implicitly. But in order to define a multicolumn constraint or index, the `cols` submodifier must be provided explicitly. When the `cols` submodifier is provided, the modifier no longer needs to be defined on a column field and can be defined on the sq.TableInfo field:

```go
type FILM_ACTOR struct {
    sq.TableInfo `ddl:"index={my_multicolumn_index cols=film_id,actor_id unique}"`
    //                                                  └──────────────┘
    //                                                  explicit columns
    FILM_ID      sq.NumberField `ddl:"references=film.film_id"`
    ACTOR_ID     sq.NumberField `ddl:"references=actor.actor_id"`
}
```
```sql
CREATE TABLE film_actor (
    film_id INT
    ,actor_id INT

    ,CONSTRAINT film_actor_film_id_fkey FOREIGN KEY (film_id) REFERENCES film (film_id)
    ,CONSTRAINT film_actor_actor_id_fkey FOREIGN KEY (actor_di) REFERENCES actor (actor_id)
)
CREATE UNIQUE INDEX my_multicolumn_index ON film_actor (film_id, actor_id);
--                                                      └───────────────┘
--                                                      explicit columns
```

Notice how the index name `my_multicolumn_index` was passed in to the index modifier. The way `ddl` struct tags work, if you want to specify a modifier you have to first pass in a value (in this case the index name). If you want to use the [default naming convention](#), you can use a period `.` as the value to signal that you wish for the name to be automatically generated.

```go
type FILM_ACTOR struct {
    sq.TableInfo `ddl:"index={. cols=film_id,actor_id unique}"`
    //                        ↑
    //                      period
    FILM_ID      sq.NumberField `ddl:"references=film.film_id"`
    ACTOR_ID     sq.NumberField `ddl:"references=actor.actor_id"`
}
```
```sql
CREATE TABLE film_actor (
    film_id INT
    ,actor_id INT

    ,CONSTRAINT film_actor_film_id_fkey FOREIGN KEY (film_id) REFERENCES film (film_id)
    ,CONSTRAINT film_actor_actor_id_fkey FOREIGN KEY (actor_di) REFERENCES actor (actor_id)
)
CREATE UNIQUE INDEX film_actor_film_id_actor_id_idx ON film_actor (film_id, actor_id);
--                                 ↑
--                    automatically generated name
```

## DDL struct tag reference

### `type`
Value: the column type.

### `auto_increment`
Value: N.A.

### `autoincrement`
Value: N.A.

### `identity`
Value: N.A.

### `alwaysidentity`
Value: N.A.

### `notnull`
Value: N.A.

### `onupdatecurrenttimestamp`
Value: N.A.

### `generated`
Value: the generated column expression.

### `stored`
Applies to columns only.

Value: N.A.

### `virtual` (column)
Applies when defined on a column (i.e. not sq.TableInfo).

Value: N.A.

### `virtual` (table)
Applies when defined on a table (i.e. sq.TableInfo).

### `collate`
Value: the column collation.

### `default`
Value: the column default.

### `primarykey`
Value: the name of the primary key constraint.

### `primarykey.cols`

### `primarykey.deferrable`

### `primarykey.deferred`

### `primarykey.ignore`

### `references`
Value: the name of the referenced column.

### `references.name`
Value: the name of the foreign key constraint.

### `references.cols`

### `references.onupdate`

### `references.ondelete`

### `references.deferrable`

### `references.deferred`

### `references.ignore`

### `unique`
Value: the name of the unique constraint.

### `unique.cols`

### `unique.ignore`

### `index`
Value: the name of the index.

### `index.cols`

### `index.unique`

### `index.using`

### `index.where`

### `index.include`

### `index.ignore`

### `ignore`

note: why aren't sequences supported? I don't think sequences are ever used explicitly, they're almost always created as an implementation side effect of using auto incremented values. If you have a need for defining sequences explicitly and would like to see it in this package, please file an issue detailing why you use them and what you want the API to look like.
