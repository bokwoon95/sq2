`ddl` is a package that introspects `sq` table structs and creates them in the database if they do not already exist. A typical workflow looks like this:

1. Define table structs corresponding to SQL tables.
2. On application startup, pass those table structs to [Migrate/AutoMigrate](#) ensure the tables exist in the database.

Table and column attributes can be defined either via **struct tags** or the **`DDLTable` interface** (or both).

`ddl` does not handle the setting of the table name or column name, that is handled by `sq` (see the documentation for [`sq.New`](#)).

## How do `sq` Fields map to SQL types?

Every Field provided by `sq` has a default SQL type, so you don't have to explicitly specify the type if the default is what you already want.

`sq.CustomField` is the exception, it is a catch-all field that is meant to accomodate other SQL types not mentioned here e.g. `INT[]`, `TEXT[]`, `TSVECTOR`. `sq.CustomField` has no default SQL type, therefore a type must always be specified.

| Field | Go Type | Default SQL type |
|-------|-----|-------|
| `sq.BlobField` | `[]byte` | `BLOB` (SQLite/MySQL), `BYTEA` (Postgres) |
| `sq.BooleanField` | `bool` | `BOOLEAN` |
| `sq.NumberField` | `int, int64, float64, etc` | `INT` |
| `sq.StringField` | `string` | `TEXT` (SQLite/Postgres), `VARCHAR(255)` (MySQL) |
| `sq.TimeField` | `time.Time` | `DATETIME` (SQLite/MySQL), `TIMESTAMPTZ` (Postgres) |
| `sq.JSONField` | any JSON compatible type | `JSON` (SQLite/MySQL), `JSONB` (Postgres) |
| `sq.UUIDField` | google/uuid | `BINARY(16)` (SQLite/MySQL), `UUID` (Postgres) |
| `sq.CustomField` | - | - |

## How to use DDL struct tags

A `ddl` struct tag consists of one or more modifiers. Modifiers are delimited by spaces.

```go
type ACTOR struct {
    sq.TableInfo
    ACTOR_ID sq.NumberField `ddl:"notnull primarykey identity"`
    //                            └─────┘ └────────┘ └──────┘
    //                           modifier  modifier   modifier
}
```
```sql
CREATE TABLE actor (
    actor_id INT NOT NULL GENERATED BY DEFAULT AS IDENTITY

    ,CONSTRAINT actor_actor_id_pkey PRIMARY KEY (actor_id)
);
```

<br>

Modifiers may have values associated with them on the right hand side of an equals '=' sign. No spaces are allowed around the '=' sign, since a space would start a new modifier.
Notice how the modifier value `DATETIME('now')` has no spaces, so no {brace quoting} is necessary.

```go
type ACTOR struct {
    sq.TableInfo
    //                                modifier value               modifier value
    //                                  ┌───────┐                 ┌─────────────┐
    LAST_UPDATE sq.TimeField `ddl:"type=TIMESTAMP notnull default=DATETIME('now')"`
    //                             └────────────┘ └─────┘ └─────────────────────┘
    //                                modifier    modifier       modifier
}
```
```sql
CREATE TABLE actor (
    last_update TIMESTAMP NOT NULL DEFAULT (DATETIME('now'))
);
```

<br>

If a modifier value does contain spaces, the entire value has to be {brace quoted} to ensure it remains a single unit.

```go
type FILM_ACTOR struct {
    sq.TableInfo
    ACTOR_ID    sq.NumberField `ddl:"notnull references=actor.actor_id"`
    //                                             brace quoted because of whitespace
    //                                               ┌────────────────────────────┐
    LAST_UPDATE sq.TimeField   `ddl:"notnull default={DATETIME('now', 'localtime')}"`
    //                               └─────┘ └────────────────────────────────────┘
    //                               modifier               modifier
}
```
```sql
CREATE TABLE film_actor (
    actor_id INT NOT NULL
    ,last_update DATETIME NOT NULL DEFAULT (DATETIME('now', 'localtime'))
    --                                                     ↑
    --                                                 whitespace

    ,CONSTRAINT film_actor_actor_id_fkey FOREIGN KEY (actor_id) REFERENCES actor (actor_id)
);
```

<br>

A modifier may have additional submodifiers. Such submodifiers are always defined after an initial modifier value, which has to be provided. When submodifiers are present, brace quoting is always necessary so that submodifiers are differentiated from top-level modifiers.

```go
type FILM_ACTOR struct {
    sq.TableInfo
    //                                                   modifier value    submodifier      submodifier
    //                                                   ┌────────────┐ ┌──────────────┐ ┌───────────────┐
    ACTOR_ID    sq.NumberField `ddl:"notnull references={actor.actor_id onupdate=cascade ondelete=restrict}"`
    //                               └─────┘ └────────────────────────────────────────────────────────────┘
    //                              modifier                         modifier
    LAST_UPDATE sq.TimeField   `ddl:"notnull default=CURRENT_TIMESTAMP"`
}
```
```sql
CREATE TABLE actor (
    actor_id INT NOT NULL
    ,last_update DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP

    ,CONSTRAINT film_actor_actor_id_fkey FOREIGN KEY (actor_id) REFERENCES actor (actor_id) ON UPDATE CASCADE ON DELETE RESTRICT
);
```

A {braced quoted} string string on the right hand side of '=' can either be
1. a modifier value containing spaces (e.g. [`default`](#))
2. a modifier value followed by submodifiers (e.g. [`references`](#))

Which one it is depends on the modifier itself. For a complete list of supported modifiers, see the [struct tag reference](#).

## Dialect-specific modifiers

A modifier may be prefixed by an SQL dialect like this: `<dialect>:<modifier>`. This indicates that the modifier is only applicable for that dialect. This is used for defining table structs that work on multiple dialects at once.

The currently valid dialect prefixes are: `sqlite`, `postgres` and `mysql`.

Modifiers are evaluated left-to-right, and so putting a dialect-less modifier at the end will always override any dialect-specific modifier defined at the beginning. Therefore, always define dialect-specific modifiers after any dialect-less modifiers of the same name.

Some modifiers are already dialect-specific e.g. `auto_increment` only applies to MySQL, `identity` only applies to postgres. In such cases no dialect prefix is needed, `ddl` will automatically ignore the modifier if it is not applicable for the current dialect.

```go
type FILM struct {
    sq.TableInfo
    FILM_ID          sq.NumberField `ddl:"sqlite:type=INTEGER primarykey auto_increment identity"`
    TITLE            sq.StringField `ddl:"mysql:type=VARCHAR(50)"`
    SPECIAL_FEATURES sq.CustomField `ddl:"type=JSON postgres:type=TEXT[]"`
}
```
```sql
-- One struct maps to three different tables for three different dialects

-- sqlite
CREATE TABLE film (
    film_id INTEGER PRIMARY KEY
    ,title TEXT
    ,special_features JSON
);

-- postgres
CREATE TABLE film (
    film_id INT GENERATED BY DEFAULT AS IDENTITY
    ,title TEXT
    ,special_features TEXT[]

    ,CONSTRAINT film_film_id PRIMARY KEY (film_id)
);

-- mysql
CREATE TABLE film (
    film_id INT AUTO_INCREMENT
    ,title VARCHAR(50)
    ,special_features JSON

    ,PRIMARY KEY (film_id)
);
```

## Default names for Constraints and Indexes

Constraints and indexes will have default names automatically generated for them if you do not provide one. The generated names follow [Postgres' naming convention](https://stackoverflow.com/a/4108266) of

`{tablename}_{columnname(s)}_{suffix}`

where the suffix is one of the following:
- `pkey` for a Primary Key constraint
- `key` for a Unique constraint
- `idx` for any other kind of index
- `fkey` for a Foreign key

Constraint names cannot be generated for CHECK or EXCLUDE constraints, because they involve SQL expressions and it is not possible to determine (on `ddl`'s side) what columns are participating in an expression. Therefore constraint names must always be explicitly specified for CHECK and EXCLUDE. In fact, it is impossible to define CHECK and EXCLUDE constraints using struct tags because I haven't figured out what the it should look like. They can only be defined through the [`DDLTable` interface](#).

To use a custom constraint or index name, pass it in as a value to the `primarykey`, `unique` or `index` modifier.

```go
type FILM struct {
    sq.TableInfo
    TITLE sq.StringField `ddl:"notnull index"`
    //                                   ↑
    //                             no name provided
    DESCRIPTION sq.StringField `ddl:"notnull index=lorem_ipsum_dolor_sit_amet"`
    //                                             └────────────────────────┘
    //                                                   name provided
}
```
```sql
CREATE TABLE film (
    title TEXT NOT NULL
    ,description TEXT NOT NULL
);
CREATE INDEX film_title_idx ON film (title);
--                  ↑
--          default index name
CREATE INDEX lorem_ipsum_dolor_sit_amet ON film (description);
--           └────────────────────────┘
--                custom index name
```

## How to specify multiple columns for an index or constraint?

The `primarykey`, `unique` and `index` modifiers accept a submodifier `cols` which takes in a comma separated list of columns participating in the constraint or index.
Usually this is not needed when the modifier is defined in the struct tag of a column field, as the field would be implicitly used for `cols`. But if multiple columns are needed, the `cols` submodifier must be defined explicitly defined.
When this happens, the modifier can be defined in the struct tag of sq.TableInfo (although any other struct tag would also work):

```go
type FILM_ACTOR struct {
    sq.TableInfo `ddl:"index={my_multicolumn_index cols=film_id,actor_id unique}"`
    //                                 ↑                └──────────────┘
    //                          custom index name       explicit columns
    FILM_ID      sq.NumberField `ddl:"references=film.film_id"`
    ACTOR_ID     sq.NumberField `ddl:"references=actor.actor_id"`
}
```
```sql
CREATE TABLE film_actor (
    film_id INT
    ,actor_id INT

    ,CONSTRAINT film_actor_film_id_fkey FOREIGN KEY (film_id) REFERENCES film (film_id)
    ,CONSTRAINT film_actor_actor_id_fkey FOREIGN KEY (actor_di) REFERENCES actor (actor_id)
)
CREATE UNIQUE INDEX my_multicolumn_index ON film_actor (film_id, actor_id);
--                            ↑                         └───────────────┘
--                     custom index name                explicit columns
```

Notice how the index name `my_multicolumn_index` was passed in to the index modifier. If you're fine with the [default naming convention](#), you can use a period `.` in place of the name to signal that you want to use the default name.

```go
type FILM_ACTOR struct {
    sq.TableInfo `ddl:"index={. cols=film_id,actor_id unique}"`
    //                        ↑
    //                      period
    FILM_ID      sq.NumberField `ddl:"references=film.film_id"`
    ACTOR_ID     sq.NumberField `ddl:"references=actor.actor_id"`
}
```
```sql
CREATE TABLE film_actor (
    film_id INT
    ,actor_id INT

    ,CONSTRAINT film_actor_film_id_fkey FOREIGN KEY (film_id) REFERENCES film (film_id)
    ,CONSTRAINT film_actor_actor_id_fkey FOREIGN KEY (actor_di) REFERENCES actor (actor_id)
)
CREATE UNIQUE INDEX film_actor_film_id_actor_id_idx ON film_actor (film_id, actor_id);
--                                 ↑
--                        default index name
```

## DDL struct tag reference

### `type`
Value: the column type. Any value passed in is literally passed to the database, spaces and all.

```go
type FILM struct {
    sq.TableInfo
    TITLE       sq.StringField `ddl:"type=VARCHAR(50)"`
    LAST_UPDATE sq.TimeField   `ddl:"type={TIMESTAMP WITH TIME ZONE}"`
}
```
```sql
CREATE TABLE film (
    title VARCHAR(50)
    ,last_update TIMESTAMP WITH TIME ZONE
);
```

This is also where you can define special types like SERIAL or ENUM.

```go
type FILM struct {
    sq.TableInfo
    FILM_ID     sq.NumberField `ddl:"type=SERIAL primarykey"`
    FILM_RATING sq.StringField `ddl:"type={ENUM('G', 'PG', 'PG-13', 'R', 'NC-17')} default='G'"`
}
```
```sql
CREATE TABLE film (
    film_id SERIAL PRIMARY KEY
    ,film_rating ENUM('G', 'PG', 'PG-13', 'R', 'NC-17') DEFAULT 'G'
);
```

NOTE: if your Postgres version is 10 or higher, [you should not be using SERIAL](https://stackoverflow.com/a/55300741/3030828). Instead, use [`identity`](#).

### `auto_increment`
Value: N.A.

MySQL only. Sets the column to be `AUTO_INCREMENT`.

```go
type FILM struct {
    sq.TableInfo
    FILM_ID sq.NumberField `ddl:"primarykey auto_increment"`
}
```
```sql
CREATE TABLE film (
    film_id INT AUTO_INCREMENT

    ,PRIMARY KEY (film_id)
);
```

### `autoincrement`
Value: N.A.

SQLite only. Sets the column to be `AUTOINCREMENT`.

```go
type FILM struct {
    sq.TableInfo
    FILM_ID sq.NumberField `ddl:"type=INTEGER primarykey autoincrement"`
}
```
```sql
CREATE TABLE film (
    film_id INTEGER PRIMARY KEY AUTOINCREMENT
);
```

NOTE: SQLite's author [recommends against using AUTOINCREMENT](https://www.sqlite.org/autoinc.html) if you just need an automatically generated primary key.
Defining `INTEGER PRIMARY KEY` on a column is enough to guarantee automatically generated values, and using AUTOINCREMENT will impose additional CPU and memory load on the database.

### `identity`
Value: N.A.

Postgres only. Sets the column to be `GENERATED BY DEFAULT AS IDENTITY`.

```go
type FILM struct {
    sq.TableInfo
    FILM_ID sq.NumberField `ddl:"primarykey identity"`
}
```
```sql
CREATE TABLE film (
    film_id INT GENERATED BY DEFAULT AS IDENTITY

    ,CONSTRAINT film_film_id_pkey PRIMARY KEY (film_id)
);
```

### `alwaysidentity`
Value: N.A.

Postgres only. Sets the column to be `GENERATED ALWAYS AS IDENTITY`.

```go
type FILM struct {
    sq.TableInfo
    FILM_ID sq.NumberField `ddl:"primarykey alwaysidentity"`
}
```
```sql
CREATE TABLE film (
    film_id INT GENERATED ALWAYS AS IDENTITY

    ,CONSTRAINT film_film_id_pkey PRIMARY KEY (film_id)
);
```

### `notnull`
Value: N.A.

Sets the column to be `NOT NULL`.

```go
type ACTOR struct {
    sq.TableInfo
    FIRST_NAME sq.StringField `ddl:"type=VARCHAR(255) notnull"`
}
```
```sql
CREATE TABLE actor (
    first_name VARCHAR(255) NOT NULL
);
```

### `onupdatecurrenttimestamp`
Value: N.A.

MySQL only. Enables `ON UPDATE CURRENT_TIMESTAMP` for the column.

```go
type ACTOR struct {
    sq.TableInfo
    LAST_UPDATE sq.TimeField `ddl:"default=CURRENT_TIMESTAMP onupdatecurrenttimestamp"`
}
```
```sql
CREATE TABLE actor (
    last_update DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);
```

### `generated`
Value: the generated column expression.

Sets the column's generated expression.

```go
type ACTOR struct {
    sq.TableInfo
    FIRST_NAME sq.StringField
    LAST_NAME  sq.StringField
    FULL_NAME  sq.StringField `ddl:"generated={first_name || ' ' || last_name} virtual"`
}
```
```sql
CREATE TABLE actor (
    first_name TEXT
    ,last_name TEXT
    ,full_name TEXT GENERATED ALWAYS AS (first_name || ' ' || last_name) VIRTUAL
)
```

### `stored`
Value: N.A.

Marks the column's generated expression as STORED. It does nothing if the column is not a generated expression.

```go
type ACTOR struct {
    sq.TableInfo
    FIRST_NAME sq.StringField
    LAST_NAME  sq.StringField
    FULL_NAME  sq.StringField `ddl:"generated={first_name || ' ' || last_name} stored"`
}
```
```sql
CREATE TABLE actor (
    first_name TEXT
    ,last_name TEXT
    ,full_name TEXT GENERATED ALWAYS AS (first_name || ' ' || last_name) STORED
)
```

### `virtual` (column)
Applies when defined on a column (i.e. not sq.TableInfo). For the other definition when defined on a table, see [`virtual`](#).

Value: N.A.

Marks the column's generated expression as VIRTUAL. It does nothing if the column is not a generated expression.

```go
type ACTOR struct {
    sq.TableInfo
    FIRST_NAME sq.StringField
    LAST_NAME  sq.StringField
    FULL_NAME  sq.StringField `ddl:"generated={first_name || ' ' || last_name} virtual"`
}
```
```sql
CREATE TABLE actor (
    first_name TEXT
    ,last_name TEXT
    ,full_name TEXT GENERATED ALWAYS AS (first_name || ' ' || last_name) VIRTUAL
)
```

NOTE: Postgres does not support `VIRTUAL` generated columns. Even if you mark a generated column as `virtual`, `ddl` will continue to treat the generated column as `STORED`. This restriction will be lifted if Postgres eventually supports `VIRTUAL` generated columns.

### `virtual` (table)
Applies when defined on a table (i.e. sq.TableInfo). For the other definition when defined on a column, see [`virtual`](#).

Value: The name of an SQLite [virtual table module](https://www.sqlite.org/vtab.html) (e.g. [FTS5](https://www.sqlite.org/fts5.html)).

SQLite only. Module arguments can be supplied after the module name (delimited by spaces).

If the module name is 'fts5' (case insensitive), the table struct columns will be passed in as module arguments as well.

```go
type FILM_TEXT struct {
    sq.TableInfo `ddl:"virtual={fts5 content='film' content_rowid='film_id'}"`
    TITLE        sq.StringField
    DESCRIPTION  sq.StringField
}
```
```sql
CREATE VIRTUAL TABLE film_text USING fts5 (
    title
    ,description
    ,content='film'
    ,content_rowid='film_id'
);
```

### `collate`
Value: the column collation.

```go
type FILM_ACTOR_REVIEW struct {
    sq.TableInfo
    REVIEW_BODY sq.StringField `ddl:"collate=C"`
}
```
```sql
CREATE TABLE film_actor_review (
    review_body TEXT COLLATE "C"
);
```

For Postgres, the column collation will always be quoted with double quotes. I do not know why this is necessary, but Postgres seems to require it. The other databases do not have this behaviour.

### `default`
Value: the column default.

If the column default is anything other than a string, number, `TRUE`, `FALSE`, `CURRENT_DATE`, `CURRENT_TIME` or `CURRENT_TIMESTAMP`, it will be considered an SQL expression. For SQLite and MySQL, `ddl` will automatically wrap expressions in brackets. This does not happen for Postgres (which does not have this restriction).

```go
type FILM struct {
    sq.TableInfo
    TITLE       sq.StringField `ddl:"default=''"`
    RENTAL_RATE sq.NumberField `ddl:"type=DECIMAL(4,2) default=4.99"`
    RATING      sq.StringField `ddl:"default='G'"`
    LAST_UPDATE sq.NumberField `ddl:"default=DATETIME('now')"`
}
```
```sql
CREATE TABLE film (
    title TEXT DEFAULT ''
    rental_rate DECIMAL(4,2) DEFAULT 4.99
    rating TEXT DEFAULT 'G'
    last_update DATETIME DEFAULT (DATETIME('now'))
);
```

### `ignore`

Value: a comma separated list of dialects. For these dialects, the column will be ignored. If the value is empty, all dialects will be ignored.

Use `ignore` on an sq.TableInfo field to ignore the entire table.

```go
type FILM struct {
    sq.TableInfo
    FILM_ID     sq.NumberField `ddl:"type=INTEGER primarykey"`
    TITLE       sq.StringField
    DESCRIPTION sq.StringField
    FULLTEXT sq.StringField `ddl:"type=TSVECTOR ignore=sqlite,mysql"`
}

type FILM_TEXT struct {
    sq.TableInfo `ddl:"ignore=postgres virtual={fts5 content='film' content_rowid='film_id'}"`
    FILM_ID       sq.NumberField `ddl:"ignore=sqlite primarykey"`
    TITLE         sq.StringField
    DESCRIPTION   sq.StringField
}
```
```sql
-- sqlite
CREATE TABLE film (
    film_id INTEGER PRIMARY KEY
    ,title TEXT
    ,description TEXT
);
CREATE VIRTUAL TABLE film_text using fts5 (
    title
    ,description
    ,content='film'
    ,content_rowid=fil
);

-- postgres
CREATE TABLE film (
    film_id INTEGER
    ,title TEXT
    ,description TEXT
    ,fulltext TSVECTOR

    ,CONSTRAINT film_film_id_pkey PRIMARY KEY (film_id)
);

-- mysql
CREATE TABLE film (
    film_id INTEGER
    ,title TEXT
    ,description TEXT

    ,PRIMARY KEY (film_id)
);
CREATE TABLE film_text (
    film_id INT
    ,title VARCHAR(255)
    ,description VARCHAR(255)

    ,PRIMARY KEY (film_id)
);
```

### `primarykey`
Value: the name of the primary key constraint. If the name is omitted or is a period `.`, the [default name](#) will be used instead.

The PRIMARY KEY constraint is usually defined in its own line in the CREATE TABLE statement, to accomodate multicolumn primary keys. However for SQLite when there is only one primary key column it will be defined inline, to allow for the [`INTEGER PRIMARY KEY` autoincrementing behaviour](http://www.sqlite.org/autoinc.html). For MySQL, the primary key constraint name is never used: MySQL hardcodes all primary key constraint names to be `PRIMARY`, regardless of whether you supplied a constraint name or not.

```go
type ACTOR struct {
    sq.TableInfo
    ACTOR_ID sq.NumberField `ddl:"type=INTEGER primarykey"`
}
```
```sql
-- sqlite
CREATE TABLE actor (
    actor_id INTEGER PRIMARY KEY
);

-- postgres
CREATE TABLE actor (
    actor_id INTEGER

    ,CONSTRAINT actor_actor_id_pkey PRIMARY KEY (actor_id)
);

-- mysql
CREATE TABLE actor (
    actor_id INTEGER

    ,PRIMARY KEY (actor_id)
);
```

### `primarykey.cols`

Value: a comma separated list of columns in the primary key. If this is omitted, the column field that the struct tag belongs to is used.

```go
type ACTOR struct {
    sq.TableInfo
    ACTOR_ID sq.NumberField `ddl:"primarykey"`
}

type FILM struct {
    sq.TableInfo `ddl:"primarykey={. cols=film_id}"`
    FILM_ID      sq.NumberField
}

type FILM_ACTOR struct {
    sq.TableInfo `ddl:"primarykey={my_multicolumn_pk cols=film_id,actor_id}"`
    FILM_ID      sq.NumberField
    ACTOR_ID     sq.NumberField
}
```
```sql
CREATE TABLE actor (
    actor_id INT

    ,CONSTRAINT actor_actor_id_pkey PRIMARY KEY (actor_id)
);

CREATE TABLE film (
    film_id INT

    ,CONSTRAINT film_film_id_pkey PRIMARY KEY (film_id)
);

CREATE TABLE film_actor (
    film_id INT
    ,actor_id INT

    ,CONSTRAINT my_multicolumn_pk PRIMARY KEY (film_id, actor_id)
);
```

### `primarykey.deferrable`

Value: N.A.

Postgres only. Sets the primary key constraint to `DEFERRABLE`.

```go
type ACTOR struct {
    sq.TableInfo
    ACTOR_ID sq.NumberField `ddl:"primarykey={. deferrable}"`
}
```
```sql
CREATE TABLE actor (
    actor_id INT

    ,CONSTRAINT actor_actor_id_pkey PRIMARY KEY (actor_id) DEFERRABLE
);
```

### `primarykey.deferred`

Value: N.A.

Postgres only. Sets the primary key constraint to `DEFERRABLE INITIALLY DEFERRED`.

```go
type ACTOR struct {
    sq.TableInfo
    ACTOR_ID sq.NumberField `ddl:"primarykey={. deferred}"`
}
```
```sql
CREATE TABLE actor (
    actor_id INT

    ,CONSTRAINT actor_actor_id_pkey PRIMARY KEY (actor_id) DEFERRABLE INITIALLY DEFERRED
);
```

### `primarykey.ignore`

Value: a comma separated list of dialects. For these dialects, the primary key constraint will be ignored. If the value is empty, all dialects will be ignored.

```go
type ACTOR struct {
    sq.TableInfo
    ACTOR_ID sq.NumberField `ddl:"primarykey={. ignored=sqlite,mysql}"`
}
```
```sql
-- sqlite
CREATE TABLE actor (
    actor_id INT
);

-- postgres
CREATE TABLE actor (
    actor_id INT

    ,CONSTRAINT actor_actor_id PRIMARY KEY (actor_id)
);

-- mysql
CREATE TABLE actor (
    actor_id INT
);
```

### `references`

Value: the name of the referenced column(s). It can take one of two forms
1. `<table>.<column(s)>`
2. `<schema>.<table>.<column(s)>` e.g. cross-schema foreign keys

If there are multiple columns referenced by the foreign key, the column names are comma separated. Note that whenever multiple columns are referenced, the foreign key itself must also have multiple columns (via the [`cols`](#) submodifier).

```go
type FILM_ACTOR struct {
    sq.TableInfo `ddl:"primarykey={. cols=film_id,actor_id}"`
    FILM_ID      sq.NumberField `ddl:"references=film.film_id"`
    ACTOR_ID     sq.NumberField `ddl:"references=actor.actor_id"`
}

type FILM_ACTOR_REVIEW struct {
    sq.TableInfo `ddl:"references={film_actor.film_id,actor_id cols=film_id,actor_id}"`
    FILM_ID      sq.NumberField
    ACTOR_ID     sq.NumberField
    REVIEW_BODY  sq.StringField
}
```
```sql
CREATE TABLE film_actor (
    film_id INT
    ,actor_id INT

    ,CONSTRAINT film_actor_film_id_actor_id_pkey PRIMARY KEY (film_id, actor_id)
    ,CONSTRAINT film_actor_film_id_fkey FOREIGN KEY (film_id) REFERENCES film (film_id)
    ,CONSTRAINT film_actor_actor_id_fkey FOREIGN KEY (actor_id) REFERENCES actor (actor_id)
);

CREATE TABLE film_actor_review (
    film_id INT
    ,actor_id INT
    ,review_body TEXT

    ,CONSTRAINT film_actor_review_film_id_actor_id_fkey FOREIGN KEY (film_id, actor_id) REFERENCES film_review (film_id, actor_id)
);
```

### `references.name`
Value: the name of the foreign key constraint.

```go
type FILM_ACTOR struct {
    sq.TableInfo
    FILM_ID  sq.NumberField `ddl:"references=film.film_id"`
    ACTOR_ID sq.NumberField `ddl:"references={actor.actor_id name=actor_ref}"`
}
```
```sql
CREATE TABLE film_actor (
    film_id INT
    ,actor_id INT

    ,CONSTRAINT film_actor_film_id_fkey FOREIGN KEY (film_id) REFERENCES film (film_id)
    ,CONSTRAINT actor_ref FOREIGN KEY (actor_id) REFERENCES actor (actor_id)
);
```

### `references.cols`

Value: a comma separated list of columns in the foreign key.

```go
type FILM_ACTOR_REVIEW struct {
    sq.TableInfo `ddl:"references={film_actor.film_id,actor_id cols=film_id,actor_id}"`
    FILM_ID      sq.NumberField
    ACTOR_ID     sq.NumberField
    REVIEW_BODY  sq.StringField
}
```
```sql
CREATE TABLE film_actor_review (
    film_id INT
    ,actor_id INT
    ,review_body TEXT

    ,CONSTRAINT film_actor_review_film_id_actor_id_fkey FOREIGN KEY (film_id, actor_id) REFERENCES film_review (film_id, actor_id)
);
```

### `references.onupdate`

Value: `cascade`, `restrict`, `noaction`, `setnull` or `setdefault`.

```go
type FILM struct {
    sq.TableInfo
    LANGUAGE_ID sq.NumberField `ddl:"references={language.language_id onupdate=cascade}"`
}
```
```sql
CREATE TABLE film (
    language_id INT

    ,CONSTRAINT film_language_id_fkey FOREIGN KEY (language_id) REFERENCES language (language_id) ON UPDATE CASCADE
);
```

### `references.ondelete`

Value: `cascade`, `restrict`, `noaction`, `setnull` or `setdefault`.

```go
type FILM struct {
    sq.TableInfo
    LANGUAGE_ID sq.NumberField `ddl:"references={language.language_id ondelete=restrict}"`
}
```
```sql
CREATE TABLE film (
    language_id INT

    ,CONSTRAINT film_language_id_fkey FOREIGN KEY (language_id) REFERENCES language (language_id) ON DELETE RESTRICT
);
```

### `references.deferrable`

Value: N.A.

SQLite and Postgres only. Sets the foreign key constraint to `DEFERRABLE`.

```go
type FILM struct {
    sq.TableInfo
    LANGUAGE_ID sq.NumberField `ddl:"references={language.language_id deferrable}"`
}
```
```sql
CREATE TABLE film (
    language_id INT

    ,CONSTRAINT film_language_id_fkey FOREIGN KEY (language_id) REFERENCES language (language_id) DEFERRABLE
);
```

### `references.deferred`

Value: N.A.

SQLite and Postgres only. Sets the foreign key constraint to `DEFERRABLE INITIALLY DEFERRED`.

```go
type FILM struct {
    sq.TableInfo
    LANGUAGE_ID sq.NumberField `ddl:"references={language.language_id deferred}"`
}
```
```sql
CREATE TABLE film (
    language_id INT

    ,CONSTRAINT film_language_id_fkey FOREIGN KEY (language_id) REFERENCES language (language_id) DEFERRABLE INITIALLY DEFERRED
);
```

### `references.ignore`

Value: a comma separated list of dialects. For these dialects, the foreign key constraint will be ignored. If the value is empty, all dialects will be ignored.

```go
type FILM struct {
    sq.TableInfo
    LANGUAGE_ID sq.NumberField `ddl:"references={language.language_id ignore=sqlite,mysql}"`
}
```
```sql
-- sqlite
CREATE TABLE film (
    language_id INT
);

-- postgres
CREATE TABLE film (
    language_id INT

    ,CONSTRAINT film_language_id_fkey FOREIGN KEY (language_id) REFERENCES language (language_id) DEFERRABLE INITIALLY DEFERRED
);

-- mysql
CREATE TABLE film (
    language_id INT
);
```

### `unique`

Value: the name of the unique constraint. If the name is omitted or is a period `.`, the [default name](#) will be used instead.

```go
type CUSTOMER struct {
    sq.TableInfo
    CUSTOMER_ID sq.NumberField `ddl:"unique=uniq_cid"`
    EMAIL       sq.StringField `ddl:"unique"`
}
```
```sql
CREATE TABLE customer (
    customer_id INT
    ,email TEXT

    ,CONSTRAINT uniq_cid UNIQUE (customer_id)
    ,CONSTRAINT customer_email_key UNIQUE (email)
);
```

### `unique.cols`

Value: a comma separated list of columns in the unique constraint. If this is omitted, the column field that the struct tag belongs to is used.

```go
type CUSTOMER struct {
    sq.TableInfo `ddl:"unique={. cols=first_name,last_name}"`
    FIRST_NAME   sq.StringField
    LAST_NAME    sq.StringField
    EMAIL        sq.StringField `ddl:"unique"`
}
```
```sql
CREATE TABLE customer (
    first_name TEXT
    ,last_name TEXT
    ,email TEXT

    ,CONSTRAINT customer_first_name_last_name_key UNIQUE (first_name, last_name)
    ,CONSTRAINT customer_email_key UNIQUE (email)
);
```

### `unique.ignore`

Value: a comma separated list of dialects. For these dialects, the unique constraint will be ignored. If the value is empty, all dialects will be ignored.

```go
type CUSTOMER struct {
    sq.TableInfo `ddl:"unique={. cols=first_name,last_name ignore=sqlite,mysql}"`
    FIRST_NAME   sq.StringField
    LAST_NAME    sq.StringField
    EMAIL        sq.StringField `ddl:"unique={. ignore=postgres}"`
}
```
```sql
-- sqlite
CREATE TABLE customer (
    first_name TEXT
    ,last_name TEXT
    ,email TEXT

    ,CONSTRAINT customer_email_key UNIQUE (email)
);

-- postgres
CREATE TABLE customer (
    first_name TEXT
    ,last_name TEXT
    ,email TEXT

    ,CONSTRAINT customer_first_name_last_name_key UNIQUE (first_name, last_name)
);

-- mysql
CREATE TABLE customer (
    first_name TEXT
    ,last_name TEXT
    ,email TEXT

    ,CONSTRAINT customer_email_key UNIQUE (email)
);
```

### `index`

Value: the name of the index. If the name is omitted or is a period `.`, the [default name](#) will be used instead.

```go
type FILM struct {
    sq.TableInfo
    TITLE       sq.StringField `ddl:"index=ix_title"`
    DESCRIPTION sq.StringField `ddl:"index"`
}
```
```sql
CREATE TABLE film (
    title TEXT
    ,description TEXT
);
CREATE INDEX ix_title ON film (title);
CREATE INDEX film_description_idx ON film (description);
```

### `index.cols`

Value: a comma separated list of columns in the index. If this is omitted, the column field that the struct tag belongs to is used.

```go
type CUSTOMER struct {
    sq.TableInfo `ddl:"index={. cols=first_name,last_name}"`
    FIRST_NAME   sq.StringField
    LAST_NAME    sq.StringField
    EMAIL        sq.StringField `ddl:"index"`
}
```
```sql
CREATE TABLE customer (
    first_name TEXT
    ,last_name TEXT
    ,email TEXT
);
CREATE INDEX customer_first_name_last_name_idx ON customer (first_name, last_name);
CREATE INDEX customer_email_idx ON customer (email);
```

### `index.unique`

Value: N.A.

Marks the index as `UNIQUE`.

```go
type CUSTOMER struct {
    sq.TableInfo
    EMAIL sq.StringField `ddl:"index={. unique}"`
}
```
```sql
CREATE TABLE customer (
    email TEXT
);
CREATE UNIQUE INDEX customer_email_idx ON customer (email);
```

### `index.using`

Value: the index type.

Postgres and MySQL only. Postgres supports `btree`, `hash`, `gist`, `gin`. MySQL supports `btree`, `hash`, `fulltext`, `spatial`.

```go
type FILM struct {
    sq.TableInfo `mysql:index={. cols=title,description using=fulltext}`
    TITLE        sq.StringField
    DESCRIPTION  sq.StringField
    FULLTEXT     sq.CustomField `ddl:"ignore=mysql type=TSVECTOR postgres:index={. using=gist}"`
}
```
```sql
-- postgres
CREATE TABLE film (
    title TEXT
    ,description TEXT
    ,fulltext TSVECTOR
);
CREATE INDEX film_fulltext_idx ON film USING gist (fulltext);

-- mysql
CREATE TABLE film (
    ,title VARCHAR(255)
    ,description VARCHAR(255)
);
CREATE FULLTEXT INDEX film_title_description_idx ON film (title, description);
```

### `index.where`

Value: a predicate expression.

SQLite and Postgres only. Sets the WHERE clause for the index (i.e. a partial index).

```go
type FILM struct {
    sq.TableInfo
    TITLE sq.StringField `ddl:"index={. where={title IS NOT NULL AND LENGTH(title) > 5}}"`
}
```
```sql
CREATE TABLE film (
    title TEXT
);
CREATE INDEX film_title_idx ON film (title) WHERE title IS NOT NULL AND LENGTH(title) > 5;
```

### `index.include`

Value: a comma separated list of columns.

Postgres only. Sets the INCLUDE clause for the index.

```go
type CUSTOMER struct {
    sq.TableInfo
    FIRST_NAME sq.StringField
    LAST_NAME  sq.StringField
    EMAIL      sq.StringField `ddl:"index={. unique include=first_name,last_name}"`
}
```
```sql
CREATE TABLE customer (
    first_name TEXT
    ,last_name TEXT
    ,email TEXT
);
CREATE UNIQUE INDEX customer_email_idx ON customer (email) INCLUDE (first_name, last_name);
```

### `index.ignore`

Value: a comma separated list of dialects. For these dialects, the index will be ignored. If the value is empty, all dialects will be ignored.

```go
type CUSTOMER struct {
    sq.TableInfo `ddl:"index={. cols=first_name,last_name ignore=sqlite,mysql}"`
    FIRST_NAME   sq.StringField
    LAST_NAME    sq.StringField
    EMAIL        sq.StringField `ddl:"index={. ignore=postgres}"`
}
```
```sql
-- sqlite
CREATE TABLE customer (
    first_name TEXT
    ,last_name TEXT
    ,email TEXT
);
CREATE INDEX customer_email_idx ON customer (email);

-- postgres
CREATE TABLE customer (
    first_name TEXT
    ,last_name TEXT
    ,email TEXT
);
CREATE INDEX customer_first_name_last_name_idx ON customer (first_name, last_name);

-- mysql
CREATE TABLE customer (
    first_name VARCHAR(255)
    ,last_name VARCHAR(255)
    ,email VARCHAR(255)
);
CREATE INDEX customer_email_idx ON customer (email);
```

# FAQ

## Why aren't sequences supported?

I've never used sequences, so I don't know how to design this feature. If you have a need for creating sequences with this package, please file an issue detailing what your ideal API would look like.
