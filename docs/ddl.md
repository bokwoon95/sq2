`ddl` is a package that can read `sq` tables and generate the DDL commands needed to construct them.

Table and column attributes can be defined on a table struct either via **struct tags** or the **`DDLer` interface** (or both).

`ddl` does not handle the setting of the table name or column name, that is handled by `sq` (see the documentation for [`sq.New`](#)).

## How are `sq` Fields mapped to SQL types?

Every Field provided by `sq` has a default SQL type, so you don't have to explicitly specify the type if the default is what you already want.

Any other unsupported SQL type `(e.g. INT[], TEXT[], TSVECTOR, etc)` is modeled by a `sq.CustomField`, which has no default type so a type must be specified.

| Field | Go Type | Default SQL type |
|-------|-----|-------|
| `sq.BlobField` | `[]byte` | `BLOB` (SQLite/MySQL), `BYTEA` (Postgres) |
| `sq.BooleanField` | `bool` | `BOOLEAN` |
| `sq.NumberField` | `int, int64, float64, etc` | `INT` |
| `sq.StringField` | `string` | `TEXT` (SQLite/Postgres), `VARCHAR(255)` (MySQL) |
| `sq.TimeField` | `time.Time` | `DATETIME` (SQLite/MySQL), `TIMESTAMPTZ` (Postgres) |
| `sq.JSONField` | any JSON compatible type | `JSON` (SQLite/MySQL), `JSONB` (Postgres) |
| `sq.UUIDField` | google/uuid | `BINARY(16)` (SQLite/MySQL), `UUID` (Postgres) |
| `sq.CustomField` | - | - |

## How to use DDL Struct tags

A `ddl` struct tag consists of one or more modifiers. Modifiers are delimited by spaces.

```go
type ACTOR struct {
    sq.TableInfo
    ACTOR_ID sq.NumberField `ddl:"notnull primarykey identity"`
}
```
```sql
CREATE TABLE actor (
    actor_id INT NOT NULL PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY
);
```

<br>
Modifiers may be have values associated with them on the right hand side of an equals '=' sign. There must not be any spaces around the '=' sign, since a space would start a new modifier.

Notice how the value `DATETIME('now')` for the `default` modifier has no spaces, so no brace quoting is necessary.

```go
type ACTOR struct {
    sq.TableInfo
    LAST_UPDATE sq.TimeField `ddl:"type=TIMESTAMP notnull default=DATETIME('now')"`
}
```
```sql
CREATE TABLE actor (
    last_update TIMESTAMP NOT NULL DEFAULT (DATETIME('now'))
);
```

<br>
If a modifier value does contain spaces, the entire value has to be {brace quoted} to ensure it remains a single unit.

```go
type FILM_ACTOR struct {
    sq.TableInfo
    ACTOR_ID    sq.NumberField `ddl:"notnull references=actor.actor_id"`
    LAST_UPDATE sq.TimeField   `ddl:"notnull default={DATETIME('now', 'localtime')}"`
    //                                                               ↑
    //                                                          whitespace
}
```
```sql
CREATE TABLE film_actor (
    actor_id INT NOT NULL REFERENCES actor (actor_id)
    ,last_update DATETIME NOT NULL DEFAULT (DATETIME('now', 'localtime'))
    --                                                     ↑
    --                                                 whitespace
);
```

<br>
Values themselves may have additional modifiers. Since modifiers are delimited by spaces, values with modifiers must always be {brace quoted}.

```go
type FILM_ACTOR struct {
    sq.TableInfo
    ACTOR_ID    sq.NumberField `ddl:"notnull references={actor.actor_id onupdate=cascade ondelete=restrict}"`
    LAST_UPDATE sq.TimeField   `ddl:"notnull default=CURRENT_TIMESTAMP"`
}
```
```sql
CREATE TABLE actor (
    actor_id INT NOT NULL REFERENCES actor (actor_id) ON UPDATE CASCADE ON DELETE RESTRICT
    ,last_update DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP
);
```

## Dialect-specific modifiers

A modifier may be prefixed by an SQL dialect like this: `<dialect>:<modifier>`. This indicates that the modifier is only applicable for that dialect. This is used for defining table structs that work on multiple dialects at once.

The currently valid dialect prefixes are: `sqlite`, `postgres` and `mysql`.

Modifiers are evaluated left-to-right, and so putting a dialect-less modifier at the end will always override any dialect-specific modifier defined at the beginning. Therefore, always define dialect-specific modifiers after any dialect-less modifiers of the same name.

Some modifiers are already dialect-specific e.g. `auto_increment` only applies to MySQL, `identity` only applies to postgres. In such cases no dialect prefix is needed, `ddl` will automatically ignore the modifier if it is not applicable for the current dialect.

```go
type FILM struct {
    sq.TableInfo
    FILM_ID          sq.NumberField `ddl:"sqlite:type=INTEGER primarykey auto_increment identity"`
    TITLE            sq.StringField `ddl:"mysql:type=VARCHAR(500)"`
    SPECIAL_FEATURES sq.CustomField `ddl:"type=JSON postgres:type=TEXT[]"`
}
```
```sql
-- sqlite
CREATE TABLE film (
    film_id INTEGER PRIMARY KEY
    ,title TEXT
    ,special_features JSON
);

-- postgres
CREATE TABLE film (
    film_id INT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY
    ,title TEXT
    ,special_features TEXT[]
);

-- mysql
CREATE TABLE film (
    film_id INT PRIMARY KEY AUTO_INCREMENT
    ,title VARCHAR(500)
    ,special_features JSON
);
```

## Default names for Constraints and Indexes

## DDL struct tag reference

### `type`
Applies to columns only.

### `auto_increment`
Applies to columns only.

### `autoincrement`
Applies to columns only.

### `identity`
Applies to columns only.

### `alwaysidentity`
Applies to columns only.

### `notnull`
Applies to columns only.

### `onupdatecurrenttimestamp`
Applies to columns only.

### `generated`
Applies to columns only.

### `stored`
Applies to columns only.

### `virtual` (column)
Applies when defined on a column (i.e. not sq.TableInfo).

### `virtual` (table)
Applies when defined on a table (i.e. sq.TableInfo).

### `collate`
Applies to columns only.

### `default`
Applies to columns only.

### `primarykey`
Applies to both tables and columns.

### `primarykey.cols`

### `primarykey.deferrable`

### `primarykey.deferred`

### `primarykey.ignore`

### `references`
Applies to both tables and columns.

### `references.name`

### `references.cols`

### `references.onupdate`

### `references.ondelete`

### `references.deferrable`

### `references.deferred`

### `references.ignore`

### `unique`
Applies to both tables and columns.

### `unique.cols`

### `unique.ignore`

### `index`
Applies to both tables and columns.

### `index.cols`

### `index.unique`

### `index.using`

### `index.where`

### `index.include`

### `index.ignore`

### `ignore`

note: why aren't sequences supported? I don't think sequences are ever used explicitly, they're almost always created as an implementation side effect of using auto incremented values. If you have a need for defining sequences explicitly and would like to see it in this package, please file an issue detailing why you use them and what you want the API to look like.
