package ddl

import (
	"bytes"

	"github.com/bokwoon95/sq"
)

type CreateTableOption int

const (
	IncludeConstraints CreateTableOption = 1 << iota
	IncludeIndices
	IncludeTableComment
	IncludeColumnComments
	IncludeIndexComments
)

func CreateTable(dialect string, tbl Table, opt CreateTableOption) (string, error) {
	buf := bufpool.Get().(*bytes.Buffer)
	defer func() {
		buf.Reset()
		bufpool.Put(buf)
	}()
	buf.WriteString("CREATE TABLE ")
	if tbl.TableSchema != "" {
		buf.WriteString(tbl.TableSchema + ".")
	}
	buf.WriteString(tbl.TableName)
	buf.WriteString(" (")
	defer func() { buf.WriteString("\n);") }()
	for i, c := range tbl.Columns {
		buf.WriteString("\n    ")
		if i > 0 {
			buf.WriteString(",")
		}
		buf.WriteString(c.ColumnName)
		if c.ColumnType != "" {
			buf.WriteString(" " + c.ColumnType)
		}
		if c.Identity != "" {
			switch dialect {
			case sq.DialectMySQL, sq.DialectSQLite:
				break // mysql and sqlite do not support identity columns
			default:
				switch c.Identity {
				case BY_DEFAULT_AS_IDENTITY:
					buf.WriteString(" GENERATED BY DEFAULT AS IDENTITY")
				case ALWAYS_AS_IDENTITY:
					buf.WriteString(" GENERATED ALWAYS AS IDENTITY")
				}
			}
		} else if c.Autoincrement {
			switch dialect {
			case sq.DialectMySQL:
				buf.WriteString(" AUTO_INCREMENT")
			case sq.DialectSQLite:
				buf.WriteString(" AUTOINCREMENT")
			}
		} else if c.GeneratedExpr != "" {
			buf.WriteString(" GENERATED ALWAYS AS (" + c.GeneratedExpr + ")")
			if c.GeneratedExprStored {
				buf.WriteString(" STORED")
			} else {
				switch dialect {
				case sq.DialectPostgres:
					break // postgres does not support virtual generated columns
				default:
					buf.WriteString(" VIRTUAL")
				}
			}
		}
		if c.IsNotNull {
			buf.WriteString(" NOT NULL")
		}
		if c.ColumnDefault != "" {
			buf.WriteString(" DEFAULT " + c.ColumnDefault)
		}
		if c.CollationName != "" {
			switch dialect {
			case sq.DialectPostgres:
				buf.WriteString(` "` + c.CollationName + `"`) // postgres collation names need double quotes (idk why)
			default:
				buf.WriteString(" " + c.CollationName)
			}
			buf.WriteString(" DEFAULT " + c.ColumnDefault)
		}
		if c.OnUpdateCurrentTimestamp {
			switch dialect {
			case sq.DialectMySQL:
				buf.WriteString(" ON UPDATE CURRENT_TIMESTAMP")
			}
		}
	}
	// if opt
	if opt == 0 {
		return buf.String(), nil
	}
	return buf.String(), nil
}

func (tbl Table) ToSQL(dialect string) (string, error) {
	buf := bufpool.Get().(*bytes.Buffer)
	defer func() {
		buf.Reset()
		bufpool.Put(buf)
	}()
	buf.WriteString("CREATE TABLE ")
	if tbl.TableSchema != "" {
		buf.WriteString(tbl.TableSchema + ".")
	}
	buf.WriteString(tbl.TableName)
	buf.WriteString(" (")
	for i, c := range tbl.Columns {
		buf.WriteString("\n    ")
		if i > 0 {
			buf.WriteString(",")
		}
		buf.WriteString(c.ColumnName)
		if c.ColumnType != "" {
			buf.WriteString(" " + c.ColumnType)
		}
		if c.Identity != "" {
			switch c.Identity {
			case BY_DEFAULT_AS_IDENTITY:
				buf.WriteString(" GENERATED BY DEFAULT AS IDENTITY")
			case ALWAYS_AS_IDENTITY:
				buf.WriteString(" GENERATED ALWAYS AS IDENTITY")
			}
		} else if c.Autoincrement {
			switch dialect {
			case sq.DialectMySQL:
				buf.WriteString(" AUTO_INCREMENT")
			default:
				buf.WriteString(" AUTOINCREMENT")
			}
		} else if c.GeneratedExpr != "" {
			buf.WriteString(" GENERATED ALWAYS AS (" + c.GeneratedExpr + ")")
			if c.GeneratedExprStored {
				buf.WriteString(" STORED")
			} else {
				buf.WriteString(" VIRTUAL")
			}
		}
		if c.IsNotNull {
			buf.WriteString(" NOT NULL")
		}
		if c.ColumnDefault != "" {
			buf.WriteString(" DEFAULT " + c.ColumnDefault)
		}
		if c.CollationName != "" {
			switch dialect {
			case sq.DialectPostgres:
				buf.WriteString(` "` + c.CollationName + `"`)
			default:
				buf.WriteString(" " + c.CollationName)
			}
			buf.WriteString(" DEFAULT " + c.ColumnDefault)
		}
		if c.OnUpdateCurrentTimestamp {
			buf.WriteString(" ON UPDATE CURRENT_TIMESTAMP")
		}
	}
	buf.WriteString("\n);")
	return buf.String(), nil
}
