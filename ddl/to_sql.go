package ddl

import (
	"bytes"

	"github.com/bokwoon95/sq"
)

func (tbl Table) ToSQL(dialect string) (string, error) {
	buf := bufpool.Get().(*bytes.Buffer)
	defer func() {
		buf.Reset()
		bufpool.Put(buf)
	}()
	buf.WriteString("CREATE TABLE ")
	if tbl.TableSchema != "" {
		buf.WriteString(tbl.TableSchema + ".")
	}
	buf.WriteString(tbl.TableName)
	buf.WriteString(" (")
	for i, c := range tbl.Columns {
		buf.WriteString("\n    ")
		if i > 0 {
			buf.WriteString(",")
		}
		buf.WriteString(c.ColumnName)
		if c.ColumnType != "" {
			buf.WriteString(" " + c.ColumnType)
		}
		if c.Identity != "" {
			switch c.Identity {
			case BY_DEFAULT_AS_IDENTITY:
				buf.WriteString(" GENERATED BY DEFAULT AS IDENTITY")
			case ALWAYS_AS_IDENTITY:
				buf.WriteString(" GENERATED ALWAYS AS IDENTITY")
			}
		} else if c.Autoincrement {
			switch dialect {
			case sq.DialectMySQL:
				buf.WriteString(" AUTO_INCREMENT")
			default:
				buf.WriteString(" AUTOINCREMENT")
			}
		} else if c.GeneratedExpr != "" {
			buf.WriteString(" GENERATED ALWAYS AS (" + c.GeneratedExpr + ")")
			if c.GeneratedExprStored {
				buf.WriteString(" STORED")
			} else {
				buf.WriteString(" VIRTUAL")
			}
		}
		if c.IsNotNull {
			buf.WriteString(" NOT NULL")
		}
		if c.ColumnDefault != "" {
			buf.WriteString(" DEFAULT " + c.ColumnDefault)
		}
		if c.CollationName != "" {
			switch dialect {
			case sq.DialectPostgres:
				buf.WriteString(` "` + c.CollationName + `"`)
			default:
				buf.WriteString(" " + c.CollationName)
			}
			buf.WriteString(" DEFAULT " + c.ColumnDefault)
		}
		if c.OnUpdateCurrentTimestamp {
			buf.WriteString(" ON UPDATE CURRENT_TIMESTAMP")
		}
	}
	buf.WriteString("\n);")
	return buf.String(), nil
}
