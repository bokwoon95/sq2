package ddl

import (
	"github.com/bokwoon95/sq"
)

func NEW_ACTOR(dialect, alias string) ACTOR {
	var tbl ACTOR
	switch dialect {
	case sq.DialectPostgres:
		tbl.GenericTable.TableSchema = "public"
	case sq.DialectMySQL:
		tbl.GenericTable.TableSchema = "db"
	}
	_ = sq.ReflectTable(&tbl, alias)
	return tbl
}

type ACTOR struct {
	sq.GenericTable
	ACTOR_ID           sq.NumberField `ddl:"type=INTEGER autoincrement primarykey"`
	FIRST_NAME         sq.StringField `ddl:"notnull"`
	LAST_NAME          sq.StringField `ddl:"notnull index"`
	FULL_NAME          sq.StringField `ddl:"generated={first_name || ' ' || last_name} virtual"`
	FULL_NAME_REVERSED sq.StringField `ddl:"generated={last_name || ' ' || first_name} stored"`
	LAST_UPDATE        sq.TimeField   `ddl:"default=DATETIME('now') notnull"`
}

func (tbl ACTOR) DDL(dialect string, t *T) {
	switch dialect {
	case sq.DialectPostgres:
		t.Column(tbl.ACTOR_ID).Type("INT").AlwaysIdentity()
		t.Column(tbl.FULL_NAME).Generated("{} || ' ' || {}", tbl.FIRST_NAME, tbl.LAST_NAME).Stored()
		t.Column(tbl.LAST_UPDATE).Type("TIMESTAMPTZ").Default("NOW()")
	case sq.DialectMySQL:
		t.Column(tbl.ACTOR_ID).Type("INT").Autoincrement()
		t.Column(tbl.FIRST_NAME).Type("VARCHAR(45)")
		t.Column(tbl.LAST_NAME).Type("VARCHAR(45)")
		t.Column(tbl.FULL_NAME).Type("VARCHAR(45)").Generated("CONCAT({}, ' ', {})", tbl.FIRST_NAME, tbl.LAST_NAME)
		t.Column(tbl.FULL_NAME_REVERSED).Config(func(c *Column) {
			c.ColumnType = "VARCHAR(45)"
			c.GeneratedExpr = t.Sprintf("CONCAT({}, ' ', {})", tbl.LAST_NAME, tbl.FIRST_NAME)
			c.GeneratedExprStored = true
		})
		t.Column(tbl.LAST_UPDATE).Type("TIMESTAMP").Default("CURRENT_TIMESTAMP").OnUpdateCurrentTimestamp()
	}
}

const ACTOR_SQLite = `CREATE TABLE actor (
    actor_id INTEGER PRIMARY KEY AUTOINCREMENT
    ,first_name TEXT NOT NULL
    ,last_name TEXT NOT NULL
    ,full_name TEXT GENERATED ALWAYS AS (first_name || ' ' || last_name) VIRTUAL
    ,full_name_reversed TEXT GENERATED ALWAYS AS (last_name || ' ' || first_name) STORED
    ,last_update DATETIME NOT NULL DEFAULT (DATETIME('now'))
);
CREATE INDEX actor_last_name_idx ON actor (last_name);`

const ACTOR_Postgres = `CREATE TABLE public.actor (
    actor_id INT GENERATED ALWAYS AS IDENTITY
    ,first_name TEXT NOT NULL
    ,last_name TEXT NOT NULL
    ,full_name TEXT GENERATED ALWAYS AS (first_name || ' ' || last_name) STORED
    ,full_name_reversed TEXT GENERATED ALWAYS AS (last_name || ' ' || first_name) STORED
    ,last_update TIMESTAMPTZ NOT NULL DEFAULT (NOW())

    ,CONSTRAINT actor_actor_id_pkey PRIMARY KEY (actor_id)
);
CREATE INDEX actor_last_name_idx ON public.actor (last_name);`

const ACTOR_MySQL = `CREATE TABLE db.actor (
    actor_id INT AUTO_INCREMENT
    ,first_name VARCHAR(45) NOT NULL
    ,last_name VARCHAR(45) NOT NULL
    ,full_name VARCHAR(45) GENERATED ALWAYS AS (CONCAT(first_name, ' ', last_name)) VIRTUAL
    ,full_name_reversed VARCHAR(45) GENERATED ALWAYS AS (CONCAT(last_name, ' ', first_name)) STORED
    ,last_update TIMESTAMP NOT NULL DEFAULT (CURRENT_TIMESTAMP) ON UPDATE CURRENT_TIMESTAMP

    ,CONSTRAINT actor_actor_id_pkey PRIMARY KEY (actor_id)
);
CREATE INDEX actor_last_name_idx ON db.actor (last_name);`

func NEW_CATEGORY(dialect, alias string) CATEGORY {
	var tbl CATEGORY
	switch dialect {
	case sq.DialectPostgres:
		tbl.GenericTable.TableSchema = "public"
	case sq.DialectMySQL:
		tbl.GenericTable.TableSchema = "db"
	}
	_ = sq.ReflectTable(&tbl, alias)
	return tbl
}

type CATEGORY struct {
	sq.GenericTable
	CATEGORY_ID sq.NumberField `ddl:"type=INTEGER primarykey"`
	NAME        sq.StringField `ddl:"notnull"`
	LAST_UPDATE sq.TimeField   `ddl:"default=DATETIME('now') notnull"`
}

func (tbl CATEGORY) DDL(dialect string, t *T) {
	switch dialect {
	case sq.DialectPostgres:
		t.Column(tbl.CATEGORY_ID).Type("INT").Identity()
		t.Column(tbl.LAST_UPDATE).Type("TIMESTAMPTZ").Default("NOW()")
	case sq.DialectMySQL:
		t.Column(tbl.CATEGORY_ID).Type("INT").Autoincrement()
		t.Column(tbl.NAME).Type("VARCHAR(25)")
		t.Column(tbl.LAST_UPDATE).Type("TIMESTAMP").Default("CURRENT_TIMESTAMP").OnUpdateCurrentTimestamp()
	}
}

const CATEGORY_SQLite = `CREATE TABLE category (
    category_id INTEGER PRIMARY KEY
    ,name TEXT NOT NULL
    ,last_update DATETIME NOT NULL DEFAULT (DATETIME('now'))
);`

const CATEGORY_Postgres = `CREATE TABLE public.category (
    category_id INT GENERATED BY DEFAULT AS IDENTITY
    ,name TEXT NOT NULL
    ,last_update TIMESTAMPTZ NOT NULL DEFAULT (NOW())

    ,CONSTRAINT category_category_id_pkey PRIMARY KEY (category_id)
);`

const CATEGORY_MySQL = `CREATE TABLE db.category (
    category_id INT AUTO_INCREMENT
    ,name VARCHAR(25) NOT NULL
    ,last_update TIMESTAMP NOT NULL DEFAULT (CURRENT_TIMESTAMP) ON UPDATE CURRENT_TIMESTAMP

    ,CONSTRAINT category_category_id_pkey PRIMARY KEY (category_id)
);`

func NEW_COUNTRY(dialect, alias string) COUNTRY {
	var tbl COUNTRY
	switch dialect {
	case sq.DialectPostgres:
		tbl.GenericTable.TableSchema = "public"
	case sq.DialectMySQL:
		tbl.GenericTable.TableSchema = "db"
	}
	_ = sq.ReflectTable(&tbl, alias)
	return tbl
}

type COUNTRY struct {
	sq.GenericTable
	COUNTRY_ID  sq.NumberField `ddl:"type=INTEGER primarykey"`
	COUNTRY     sq.StringField `ddl:"notnull"`
	LAST_UPDATE sq.TimeField   `ddl:"default=DATETIME('now') notnull"`
}

func (tbl COUNTRY) DDL(dialect string, t *T) {
	switch dialect {
	case sq.DialectPostgres:
		t.Column(tbl.COUNTRY_ID).Type("INT").Identity()
		t.Column(tbl.LAST_UPDATE).Type("TIMESTAMPTZ").Default("NOW()")
	case sq.DialectMySQL:
		t.Column(tbl.COUNTRY_ID).Type("INT").Autoincrement()
		t.Column(tbl.COUNTRY).Type("VARCHAR(50)")
		t.Column(tbl.LAST_UPDATE).Type("TIMESTAMP").Default("CURRENT_TIMESTAMP").OnUpdateCurrentTimestamp()
	}
}

const COUNTRY_SQLite = `CREATE TABLE country (
    country_id INTEGER PRIMARY KEY
    ,country TEXT NOT NULL
    ,last_update DATETIME NOT NULL DEFAULT (DATETIME('now'))
);`

const COUNTRY_Postgres = `CREATE TABLE public.country (
    country_id INT GENERATED BY DEFAULT AS IDENTITY
    ,country TEXT NOT NULL
    ,last_update TIMESTAMPTZ NOT NULL DEFAULT (NOW())

    ,CONSTRAINT country_country_id_pkey PRIMARY KEY (country_id)
);`

const COUNTRY_MySQL = `CREATE TABLE db.country (
    country_id INT AUTO_INCREMENT
    ,country VARCHAR(50) NOT NULL
    ,last_update TIMESTAMP NOT NULL DEFAULT (CURRENT_TIMESTAMP) ON UPDATE CURRENT_TIMESTAMP

    ,CONSTRAINT country_country_id_pkey PRIMARY KEY (country_id)
);`

func NEW_CITY(dialect, alias string) CITY {
	var tbl CITY
	switch dialect {
	case sq.DialectPostgres:
		tbl.GenericTable.TableSchema = "public"
	case sq.DialectMySQL:
		tbl.GenericTable.TableSchema = "db"
	}
	_ = sq.ReflectTable(&tbl, alias)
	return tbl
}

type CITY struct {
	sq.GenericTable
	CITY_ID     sq.NumberField `ddl:"type=INTEGER primarykey"`
	CITY        sq.StringField `ddl:"notnull"`
	COUNTRY_ID  sq.NumberField `ddl:"notnull references={country onupdate=cascade ondelete=restrict} index"`
	LAST_UPDATE sq.TimeField   `ddl:"default=DATETIME('now') notnull"`
}

func (tbl CITY) DDL(dialect string, t *T) {
	COUNTRY := NEW_COUNTRY(dialect, "")
	switch dialect {
	case sq.DialectSQLite:
		t.ForeignKey(tbl.COUNTRY_ID).References(COUNTRY, COUNTRY.COUNTRY_ID).OnUpdate(CASCADE).OnDelete(RESTRICT)
	case sq.DialectPostgres:
		t.Column(tbl.CITY_ID).Type("INT").Identity()
		t.Column(tbl.LAST_UPDATE).Type("TIMESTAMPTZ").Default("NOW()")
	case sq.DialectMySQL:
		t.Column(tbl.CITY_ID).Type("INT").Autoincrement()
		t.Column(tbl.CITY).Type("VARCHAR(50)")
		t.Column(tbl.LAST_UPDATE).Type("TIMESTAMP").Default("CURRENT_TIMESTAMP").OnUpdateCurrentTimestamp()
		t.ForeignKey(tbl.COUNTRY_ID).References(COUNTRY, COUNTRY.COUNTRY_ID).OnUpdate(CASCADE).OnDelete(RESTRICT)
	}
}

const CITY_SQLite = `CREATE TABLE city (
    city_id INTEGER PRIMARY KEY
    ,city TEXT NOT NULL
    ,country_id INT NOT NULL
    ,last_update DATETIME NOT NULL DEFAULT (DATETIME('now'))

    ,CONSTRAINT city_country_id_fkey FOREIGN KEY (country_id) REFERENCES country (country_id) ON UPDATE CASCADE ON DELETE RESTRICT
);
CREATE INDEX city_country_id_idx ON city (country_id);`

const CITY_Postgres = `CREATE TABLE public.city (
    city_id INT GENERATED BY DEFAULT AS IDENTITY
    ,city TEXT NOT NULL
    ,country_id INT NOT NULL
    ,last_update TIMESTAMPTZ NOT NULL DEFAULT (NOW())

    ,CONSTRAINT city_city_id_pkey PRIMARY KEY (city_id)
);
ALTER TABLE public.city ADD CONSTRAINT city_country_id_fkey FOREIGN KEY (country_id) REFERENCES country ON UPDATE CASCADE ON DELETE RESTRICT;
CREATE INDEX city_country_id_idx ON public.city (country_id);`

const CITY_MySQL = `CREATE TABLE db.city (
    city_id INT AUTO_INCREMENT
    ,city VARCHAR(50) NOT NULL
    ,country_id INT NOT NULL
    ,last_update TIMESTAMP NOT NULL DEFAULT (CURRENT_TIMESTAMP) ON UPDATE CURRENT_TIMESTAMP

    ,CONSTRAINT city_city_id_pkey PRIMARY KEY (city_id)
);
ALTER TABLE db.city ADD CONSTRAINT city_country_id_fkey FOREIGN KEY (country_id) REFERENCES country (country_id) ON UPDATE CASCADE ON DELETE RESTRICT;
CREATE INDEX city_country_id_idx ON db.city (country_id);`

func NEW_ADDRESS(dialect, alias string) ADDRESS {
	var tbl ADDRESS
	switch dialect {
	case sq.DialectPostgres:
		tbl.GenericTable.TableSchema = "public"
	case sq.DialectMySQL:
		tbl.GenericTable.TableSchema = "db"
	}
	_ = sq.ReflectTable(&tbl, alias)
	return tbl
}

type ADDRESS struct {
	sq.GenericTable
	ADDRESS_ID  sq.NumberField `ddl:"type=INTEGER primarykey"`
	ADDRESS     sq.StringField `ddl:"notnull"`
	ADDRESS2    sq.StringField
	DISTRICT    sq.StringField `ddl:"notnull"`
	CITY_ID     sq.NumberField `ddl:"notnull references={city.city_id onupdate=cascade ondelete=restrict} index"`
	POSTAL_CODE sq.StringField
	PHONE       sq.StringField `ddl:"notnull"`
	LAST_UPDATE sq.TimeField   `ddl:"default=DATETIME('now') notnull"`
}

func (tbl ADDRESS) DDL(dialect string, t *T) {
	switch dialect {
	case sq.DialectPostgres:
		t.Column(tbl.ADDRESS_ID).Type("INT").Identity()
		t.Column(tbl.LAST_UPDATE).Type("TIMESTAMPTZ").Default("NOW()")
	case sq.DialectMySQL:
		t.Column(tbl.ADDRESS_ID).Type("INT").Autoincrement()
		t.Column(tbl.ADDRESS).Type("VARCHAR(50)")
		t.Column(tbl.ADDRESS2).Type("VARCHAR(50)")
		t.Column(tbl.DISTRICT).Type("VARCHAR(20)")
		t.Column(tbl.POSTAL_CODE).Type("VARCHAR(10)")
		t.Column(tbl.PHONE).Type("VARCHAR(20)")
		t.Column(tbl.LAST_UPDATE).Type("TIMESTAMP").Default("CURRENT_TIMESTAMP").OnUpdateCurrentTimestamp()
	}
}

const ADDRESS_SQLite = `CREATE TABLE address (
    address_id INTEGER PRIMARY KEY
    ,address TEXT NOT NULL
    ,address2 TEXT
    ,district TEXT NOT NULL
    ,city_id INT NOT NULL
    ,postal_code TEXT
    ,phone TEXT NOT NULL
    ,last_update DATETIME NOT NULL DEFAULT (DATETIME('now'))

    ,CONSTRAINT address_city_id_fkey FOREIGN KEY (city_id) REFERENCES city (city_id) ON UPDATE CASCADE ON DELETE RESTRICT
);
CREATE INDEX address_city_id_idx ON address (city_id);`

const ADDRESS_Postgres = `CREATE TABLE public.address (
    address_id INT GENERATED BY DEFAULT AS IDENTITY
    ,address TEXT NOT NULL
    ,address2 TEXT
    ,district TEXT NOT NULL
    ,city_id INT NOT NULL
    ,postal_code TEXT
    ,phone TEXT NOT NULL
    ,last_update TIMESTAMPTZ NOT NULL DEFAULT (NOW())

    ,CONSTRAINT address_address_id_pkey PRIMARY KEY (address_id)
);
ALTER TABLE public.address ADD CONSTRAINT address_city_id_fkey FOREIGN KEY (city_id) REFERENCES city (city_id) ON UPDATE CASCADE ON DELETE RESTRICT;
CREATE INDEX address_city_id_idx ON public.address (city_id);`

const ADDRESS_MySQL = `CREATE TABLE db.address (
    address_id INT AUTO_INCREMENT
    ,address VARCHAR(50) NOT NULL
    ,address2 VARCHAR(50)
    ,district VARCHAR(20) NOT NULL
    ,city_id INT NOT NULL
    ,postal_code VARCHAR(10)
    ,phone VARCHAR(20) NOT NULL
    ,last_update TIMESTAMP NOT NULL DEFAULT (CURRENT_TIMESTAMP) ON UPDATE CURRENT_TIMESTAMP

    ,CONSTRAINT address_address_id_pkey PRIMARY KEY (address_id)
);
ALTER TABLE db.address ADD CONSTRAINT address_city_id_fkey FOREIGN KEY (city_id) REFERENCES city (city_id) ON UPDATE CASCADE ON DELETE RESTRICT;
CREATE INDEX address_city_id_idx ON db.address (city_id);`

func NEW_LANGUAGE(dialect, alias string) LANGUAGE {
	var tbl LANGUAGE
	switch dialect {
	case sq.DialectPostgres:
		tbl.GenericTable.TableSchema = "public"
	case sq.DialectMySQL:
		tbl.GenericTable.TableSchema = "db"
	}
	_ = sq.ReflectTable(&tbl, alias)
	return tbl
}

type LANGUAGE struct {
	sq.GenericTable
	LANGUAGE_ID sq.NumberField `ddl:"type=INTEGER primarykey"`
	NAME        sq.StringField `ddl:"notnull"`
	LAST_UPDATE sq.TimeField   `ddl:"default=DATETIME('now') notnull"`
}

func (tbl LANGUAGE) DDL(dialect string, t *T) {
	switch dialect {
	case sq.DialectPostgres:
		t.Column(tbl.LANGUAGE_ID).Type("INT").Identity()
		t.Column(tbl.LAST_UPDATE).Type("TIMESTAMPTZ").Default("NOW()")
	case sq.DialectMySQL:
		t.Column(tbl.LANGUAGE_ID).Type("INT").Autoincrement()
		t.Column(tbl.NAME).Type("CHAR(20)")
		t.Column(tbl.LAST_UPDATE).Type("TIMESTAMP").Default("CURRENT_TIMESTAMP").OnUpdateCurrentTimestamp()
	}
}

const LANGUAGE_SQLite = `CREATE TABLE language (
    language_id INTEGER PRIMARY KEY
    ,name TEXT NOT NULL
    ,last_update DATETIME NOT NULL DEFAULT (DATETIME('now'))
);`

const LANGUAGE_Postgres = `CREATE TABLE public.language (
    language_id INT GENERATED BY DEFAULT AS IDENTITY
    ,name TEXT NOT NULL
    ,last_update TIMESTAMPTZ NOT NULL DEFAULT (NOW())

    ,CONSTRAINT language_language_id_pkey PRIMARY KEY (language_id)
);`

const LANGUAGE_MySQL = `CREATE TABLE db.language (
    language_id INT AUTO_INCREMENT
    ,name CHAR(20) NOT NULL
    ,last_update TIMESTAMP NOT NULL DEFAULT (CURRENT_TIMESTAMP) ON UPDATE CURRENT_TIMESTAMP

    ,CONSTRAINT language_language_id_pkey PRIMARY KEY (language_id)
);`

func NEW_FILM(dialect, alias string) FILM {
	var tbl FILM
	switch dialect {
	case sq.DialectPostgres:
		tbl.GenericTable.TableSchema = "public"
	case sq.DialectMySQL:
		tbl.GenericTable.TableSchema = "db"
	}
	_ = sq.ReflectTable(&tbl, alias)
	return tbl
}

type FILM struct {
	sq.GenericTable
	FILM_ID              sq.NumberField `ddl:"type=INTEGER primarykey"`
	TITLE                sq.StringField `ddl:"notnull index"`
	DESCRIPTION          sq.StringField
	RELEASE_YEAR         sq.NumberField
	LANGUAGE_ID          sq.NumberField `ddl:"notnull references={language.language_id onupdate=cascade ondelete=restrict} index"`
	ORIGINAL_LANGUAGE_ID sq.NumberField `ddl:"references={language.language_id onupdate=cascade ondelete=restrict} index"`
	RENTAL_DURATION      sq.NumberField `ddl:"default=3 notnull"`
	RENTAL_RATE          sq.NumberField `ddl:"type=DECIMAL(4,2) default=4.99 notnull"`
	LENGTH               sq.NumberField
	REPLACEMENT_COST     sq.NumberField  `ddl:"type=DECIMAL(5,2) default=19.99 notnull"`
	RATING               sq.StringField  `ddl:"default='G'"`
	SPECIAL_FEATURES     sq.GenericField `ddl:"type=JSON"`
	LAST_UPDATE          sq.TimeField    `ddl:"default=DATETIME('now') notnull"`
	FULLTEXT             sq.StringField  `ddl:"notnull"`
}

func (tbl FILM) DDL(dialect string, t *T) {
	switch dialect {
	case sq.DialectSQLite:
		t.Column(tbl.FULLTEXT).Ignore()
		t.Check("film_release_year_check", "{1} >= 1901 AND {1} <= 2155", tbl.RELEASE_YEAR)
		t.Check("film_rating_check", "{} IN ('G','PG','PG-13','R','NC-17')", tbl.RATING)
	case sq.DialectPostgres:
		t.Column(tbl.FILM_ID).Type("INT").Identity()
		t.Column(tbl.RELEASE_YEAR).Type("year")
		t.Column(tbl.RATING).Type("mpaa_rating").Default("'G'::mpaa_rating")
		t.Column(tbl.LAST_UPDATE).Type("TIMESTAMPTZ").Default("NOW()")
		t.Column(tbl.SPECIAL_FEATURES).Type("TEXT[]")
		t.Column(tbl.FULLTEXT).Type("TSVECTOR")
	case sq.DialectMySQL:
		t.Column(tbl.FILM_ID).Type("INT").Autoincrement()
		t.Column(tbl.TITLE).Type("VARCHAR(255)")
		t.Column(tbl.DESCRIPTION).Type("TEXT")
		t.Column(tbl.RATING).Type("ENUM('G','PG','PG-13','R','NC-17')")
		t.Column(tbl.LAST_UPDATE).Type("TIMESTAMP").Default("CURRENT_TIMESTAMP").OnUpdateCurrentTimestamp()
		t.Column(tbl.FULLTEXT).Ignore()
		t.Check("film_release_year_check", "{1} >= 1901 AND {1} <= 2155", tbl.RELEASE_YEAR)
	}
}

const FILM_SQLite = `CREATE TABLE film (
    film_id INTEGER PRIMARY KEY
    ,title TEXT NOT NULL
    ,description TEXT
    ,release_year INT
    ,language_id INT NOT NULL
    ,original_language_id INT
    ,rental_duration INT NOT NULL DEFAULT (3)
    ,rental_rate DECIMAL(4,2) NOT NULL DEFAULT (4.99)
    ,length INT
    ,replacement_cost DECIMAL(5,2) NOT NULL DEFAULT (19.99)
    ,rating TEXT DEFAULT ('G')
    ,special_features JSON
    ,last_update DATETIME NOT NULL DEFAULT (DATETIME('now'))

    ,CONSTRAINT film_language_id_fkey FOREIGN KEY (language_id) REFERENCES language (language_id) ON UPDATE CASCADE ON DELETE RESTRICT
    ,CONSTRAINT film_original_language_id_fkey FOREIGN KEY (original_language_id) REFERENCES language (language_id) ON UPDATE CASCADE ON DELETE RESTRICT
    ,CONSTRAINT film_release_year_check CHECK (release_year >= 1901 AND release_year <= 2155)
    ,CONSTRAINT film_rating_check CHECK (rating IN ('G','PG','PG-13','R','NC-17'))
);
CREATE INDEX film_title_idx ON film (title);
CREATE INDEX film_language_id_idx ON film (language_id);
CREATE INDEX film_original_language_id_idx ON film (original_language_id);`

const FILM_Postgres = `CREATE TABLE public.film (
    film_id INT GENERATED BY DEFAULT AS IDENTITY
    ,title TEXT NOT NULL
    ,description TEXT
    ,release_year year
    ,language_id INT NOT NULL
    ,original_language_id INT
    ,rental_duration INT NOT NULL DEFAULT (3)
    ,rental_rate DECIMAL(4,2) NOT NULL DEFAULT (4.99)
    ,length INT
    ,replacement_cost DECIMAL(5,2) NOT NULL DEFAULT (19.99)
    ,rating mpaa_rating DEFAULT ('G'::mpaa_rating)
    ,special_features TEXT[]
    ,last_update TIMESTAMPTZ NOT NULL DEFAULT (NOW())
    ,fulltext TSVECTOR NOT NULL

    ,CONSTRAINT film_film_id_pkey PRIMARY KEY (film_id)
);
ALTER TABLE public.film ADD CONSTRAINT film_language_id_fkey FOREIGN KEY (language_id) REFERENCES language (language_id) ON UPDATE CASCADE ON DELETE RESTRICT;
ALTER TABLE public.film ADD CONSTRAINT film_original_language_id_fkey FOREIGN KEY (original_language_id) REFERENCES language (language_id) ON UPDATE CASCADE ON DELETE RESTRICT;
CREATE INDEX film_title_idx ON public.film (title);
CREATE INDEX film_language_id_idx ON public.film (language_id);
CREATE INDEX film_original_language_id_idx ON public.film (original_language_id);`

const FILM_MySQL = `CREATE TABLE db.film (
    film_id INT AUTO_INCREMENT
    ,title VARCHAR(255) NOT NULL
    ,description TEXT
    ,release_year INT
    ,language_id INT NOT NULL
    ,original_language_id INT
    ,rental_duration INT NOT NULL DEFAULT (3)
    ,rental_rate DECIMAL(4,2) NOT NULL DEFAULT (4.99)
    ,length INT
    ,replacement_cost DECIMAL(5,2) NOT NULL DEFAULT (19.99)
    ,rating ENUM('G','PG','PG-13','R','NC-17') DEFAULT ('G')
    ,special_features JSON
    ,last_update TIMESTAMP NOT NULL DEFAULT (CURRENT_TIMESTAMP) ON UPDATE CURRENT_TIMESTAMP

    ,CONSTRAINT film_film_id_pkey PRIMARY KEY (film_id)
    ,CONSTRAINT film_release_year_check CHECK (release_year >= 1901 AND release_year <= 2155)
);
ALTER TABLE db.film ADD CONSTRAINT film_language_id_fkey FOREIGN KEY (language_id) REFERENCES language (language_id) ON UPDATE CASCADE ON DELETE RESTRICT;
ALTER TABLE db.film ADD CONSTRAINT film_original_language_id_fkey FOREIGN KEY (original_language_id) REFERENCES language (language_id) ON UPDATE CASCADE ON DELETE RESTRICT;
CREATE INDEX film_title_idx ON db.film (title);
CREATE INDEX film_language_id_idx ON db.film (language_id);
CREATE INDEX film_original_language_id_idx ON db.film (original_language_id);`

func NEW_FILM_TEXT(dialect, alias string) FILM_TEXT {
	var tbl FILM_TEXT
	switch dialect {
	case sq.DialectPostgres:
		tbl.GenericTable.TableSchema = "public"
	case sq.DialectMySQL:
		tbl.GenericTable.TableSchema = "db"
	}
	_ = sq.ReflectTable(&tbl, alias)
	return tbl
}

type FILM_TEXT struct {
	sq.GenericTable `sq:"name=film_text" ddl:"fts5={content='film' content_rowid='film_id'}"`
	FILM_ID         sq.NumberField
	TITLE           sq.StringField
	DESCRIPTION     sq.StringField
}

func (tbl FILM_TEXT) DDL(dialect string, t *T) {
	switch dialect {
	case sq.DialectPostgres: // no-op, we will ignore this table if postgres
	case sq.DialectMySQL:
		t.Column(tbl.TITLE).Type("VARCHAR(255)").NotNull()
		t.Index(tbl.TITLE, tbl.DESCRIPTION).Using("FULLTEXT")
	case sq.DialectSQLite:
		t.Column(tbl.FILM_ID).Ignore() // Ignore will literally delete the column from t.Table.Columns
	}
}

const FILM_TEXT_SQLite = ``

const FILM_TEXT_Postgres = ``

const FILM_TEXT_MySQL = ``

func NEW_FILM_ACTOR(dialect, alias string) FILM_ACTOR {
	var tbl FILM_ACTOR
	switch dialect {
	case sq.DialectPostgres:
		tbl.GenericTable.TableSchema = "public"
	case sq.DialectMySQL:
		tbl.GenericTable.TableSchema = "db"
	}
	_ = sq.ReflectTable(&tbl, alias)
	return tbl
}

type FILM_ACTOR struct {
	sq.GenericTable `ddl:"index={. cols=actor_id,film_id unique}"`
	ACTOR_ID        sq.NumberField `ddl:"notnull references={actor.actor_id onupdate=cascade ondelete=restrict}"`
	FILM_ID         sq.NumberField `ddl:"notnull references={film.film_id onupdate=cascade ondelete=restrict} index"`
	LAST_UPDATE     sq.TimeField   `ddl:"default=DATETIME('now') notnull"`
}

func (tbl FILM_ACTOR) DDL(dialect string, t *T) {
	t.Index(tbl.ACTOR_ID, tbl.FILM_ID).Unique()
	switch dialect {
	case sq.DialectPostgres:
		t.Column(tbl.LAST_UPDATE).Type("TIMESTAMPTZ").Default("NOW()")
	case sq.DialectMySQL:
		t.Column(tbl.LAST_UPDATE).Type("TIMESTAMP").Default("CURRENT_TIMESTAMP").OnUpdateCurrentTimestamp()
	}
}

const FILM_ACTOR_SQLite = `CREATE TABLE film_actor (
    actor_id INT NOT NULL
    ,film_id INT NOT NULL
    ,last_update DATETIME NOT NULL DEFAULT (DATETIME('now'))

    ,CONSTRAINT film_actor_actor_id_fkey FOREIGN KEY (actor_id) REFERENCES actor (actor_id) ON UPDATE CASCADE ON DELETE RESTRICT
    ,CONSTRAINT film_actor_film_id_fkey FOREIGN KEY (film_id) REFERENCES film (film_id) ON UPDATE CASCADE ON DELETE RESTRICT
);
CREATE UNIQUE INDEX film_actor_actor_id_film_id_idx ON film_actor (actor_id, film_id);
CREATE INDEX film_actor_film_id_idx ON film_actor (film_id);`

const FILM_ACTOR_Postgres = `CREATE TABLE public.film_actor (
    actor_id INT NOT NULL
    ,film_id INT NOT NULL
    ,last_update TIMESTAMPTZ NOT NULL DEFAULT (NOW())
);
ALTER TABLE public.film_actor ADD CONSTRAINT film_actor_actor_id_fkey FOREIGN KEY (actor_id) REFERENCES actor (actor_id) ON UPDATE CASCADE ON DELETE RESTRICT;
ALTER TABLE public.film_actor ADD CONSTRAINT film_actor_film_id_fkey FOREIGN KEY (film_id) REFERENCES film (film_id) ON UPDATE CASCADE ON DELETE RESTRICT;
CREATE UNIQUE INDEX film_actor_actor_id_film_id_idx ON public.film_actor (actor_id, film_id);
CREATE INDEX film_actor_film_id_idx ON public.film_actor (film_id);`

const FILM_ACTOR_MySQL = `CREATE TABLE db.film_actor (
    actor_id INT NOT NULL
    ,film_id INT NOT NULL
    ,last_update TIMESTAMP NOT NULL DEFAULT (CURRENT_TIMESTAMP) ON UPDATE CURRENT_TIMESTAMP
);
ALTER TABLE db.film_actor ADD CONSTRAINT film_actor_actor_id_fkey FOREIGN KEY (actor_id) REFERENCES actor (actor_id) ON UPDATE CASCADE ON DELETE RESTRICT;
ALTER TABLE db.film_actor ADD CONSTRAINT film_actor_film_id_fkey FOREIGN KEY (film_id) REFERENCES film (film_id) ON UPDATE CASCADE ON DELETE RESTRICT;
CREATE UNIQUE INDEX film_actor_actor_id_film_id_idx ON db.film_actor (actor_id, film_id);
CREATE INDEX film_actor_film_id_idx ON db.film_actor (film_id);`

func NEW_FILM_CATEGORY(dialect, alias string) FILM_CATEGORY {
	var tbl FILM_CATEGORY
	switch dialect {
	case sq.DialectPostgres:
		tbl.GenericTable.TableSchema = "public"
	case sq.DialectMySQL:
		tbl.GenericTable.TableSchema = "db"
	}
	_ = sq.ReflectTable(&tbl, alias)
	return tbl
}

type FILM_CATEGORY struct {
	sq.GenericTable
	FILM_ID     sq.NumberField `ddl:"notnull references={film.film_id onupdate=cascade ondelete=restrict}"`
	CATEGORY_ID sq.NumberField `ddl:"notnull references={category.category_id onupdate=cascade ondelete=restrict}"`
	LAST_UPDATE sq.TimeField   `ddl:"default=DATETIME('now') notnull"`
}

func (tbl FILM_CATEGORY) DDL(dialect string, t *T) {
	switch dialect {
	case sq.DialectPostgres:
		t.Column(tbl.LAST_UPDATE).Type("TIMESTAMPTZ").Default("NOW()")
	case sq.DialectMySQL:
		t.Column(tbl.LAST_UPDATE).Type("TIMESTAMP").Default("CURRENT_TIMESTAMP").OnUpdateCurrentTimestamp()
	}
}

const FILM_CATEGORY_SQLite = `CREATE TABLE film_category (
    film_id INT NOT NULL
    ,category_id INT NOT NULL
    ,last_update DATETIME NOT NULL DEFAULT (DATETIME('now'))

    ,CONSTRAINT film_category_film_id_fkey FOREIGN KEY (film_id) REFERENCES film (film_id) ON UPDATE CASCADE ON DELETE RESTRICT
    ,CONSTRAINT film_category_category_id_fkey FOREIGN KEY (category_id) REFERENCES category (category_id) ON UPDATE CASCADE ON DELETE RESTRICT
);`

const FILM_CATEGORY_Postgres = `CREATE TABLE public.film_category (
    film_id INT NOT NULL
    ,category_id INT NOT NULL
    ,last_update TIMESTAMPTZ NOT NULL DEFAULT (NOW())
);
ALTER TABLE public.film_category ADD CONSTRAINT film_category_film_id_fkey FOREIGN KEY (film_id) REFERENCES film (film_id) ON UPDATE CASCADE ON DELETE RESTRICT;
ALTER TABLE public.film_category ADD CONSTRAINT film_category_category_id_fkey FOREIGN KEY (category_id) REFERENCES category (category_id) ON UPDATE CASCADE ON DELETE RESTRICT;`

const FILM_CATEGORY_MySQL = `CREATE TABLE db.film_category (
    film_id INT NOT NULL
    ,category_id INT NOT NULL
    ,last_update TIMESTAMP NOT NULL DEFAULT (CURRENT_TIMESTAMP) ON UPDATE CURRENT_TIMESTAMP
);
ALTER TABLE db.film_category ADD CONSTRAINT film_category_film_id_fkey FOREIGN KEY (film_id) REFERENCES film (film_id) ON UPDATE CASCADE ON DELETE RESTRICT;
ALTER TABLE db.film_category ADD CONSTRAINT film_category_category_id_fkey FOREIGN KEY (category_id) REFERENCES category (category_id) ON UPDATE CASCADE ON DELETE RESTRICT;`

func NEW_STAFF(dialect, alias string) STAFF {
	var tbl STAFF
	switch dialect {
	case sq.DialectPostgres:
		tbl.GenericTable.TableSchema = "public"
	case sq.DialectMySQL:
		tbl.GenericTable.TableSchema = "db"
	}
	_ = sq.ReflectTable(&tbl, alias)
	return tbl
}

type STAFF struct {
	sq.GenericTable
	STAFF_ID    sq.NumberField `ddl:"type=INTEGER primarykey"`
	FIRST_NAME  sq.StringField `ddl:"notnull"`
	LAST_NAME   sq.StringField `ddl:"notnull"`
	ADDRESS_ID  sq.NumberField `ddl:"notnull references={address.address_id onupdate=cascade ondelete=restrict}"`
	EMAIL       sq.StringField
	STORE_ID    sq.NumberField  `ddl:"references=store.store_id"`
	ACTIVE      sq.BooleanField `ddl:"default=TRUE notnull"`
	USERNAME    sq.StringField  `ddl:"notnull"`
	PASSWORD    sq.StringField
	LAST_UPDATE sq.TimeField `ddl:"default=DATETIME('now') notnull"`
	PICTURE     sq.BlobField
}

func (tbl STAFF) DDL(dialect string, t *T) {
	switch dialect {
	case sq.DialectPostgres:
		t.Column(tbl.STAFF_ID).Type("INT").Identity()
		t.Column(tbl.LAST_UPDATE).Type("TIMESTAMPTZ").Default("NOW()")
		t.Column(tbl.PICTURE).Type("BYTEA")
	case sq.DialectMySQL:
		t.Column(tbl.STAFF_ID).Type("INT").Autoincrement()
		t.Column(tbl.FIRST_NAME).Type("VARCHAR(45)")
		t.Column(tbl.LAST_NAME).Type("VARCHAR(45)")
		t.Column(tbl.EMAIL).Type("VARCHAR(50)")
		t.Column(tbl.USERNAME).Type("VARCHAR(16)")
		t.Column(tbl.PASSWORD).Type("VARCHAR(40)")
		t.Column(tbl.LAST_UPDATE).Type("TIMESTAMP").Default("CURRENT_TIMESTAMP").OnUpdateCurrentTimestamp()
	}
}

const STAFF_SQLite = `CREATE TABLE staff (
    staff_id INTEGER PRIMARY KEY
    ,first_name TEXT NOT NULL
    ,last_name TEXT NOT NULL
    ,address_id INT NOT NULL
    ,email TEXT
    ,store_id INT
    ,active BOOLEAN NOT NULL DEFAULT (TRUE)
    ,username TEXT NOT NULL
    ,password TEXT
    ,last_update DATETIME NOT NULL DEFAULT (DATETIME('now'))
    ,picture BLOB

    ,CONSTRAINT staff_address_id_fkey FOREIGN KEY (address_id) REFERENCES address (address_id) ON UPDATE CASCADE ON DELETE RESTRICT
    ,CONSTRAINT staff_store_id_fkey FOREIGN KEY (store_id) REFERENCES store (store_id)
);`

const STAFF_Postgres = `CREATE TABLE public.staff (
    staff_id INT GENERATED BY DEFAULT AS IDENTITY
    ,first_name TEXT NOT NULL
    ,last_name TEXT NOT NULL
    ,address_id INT NOT NULL
    ,email TEXT
    ,store_id INT
    ,active BOOLEAN NOT NULL DEFAULT (TRUE)
    ,username TEXT NOT NULL
    ,password TEXT
    ,last_update TIMESTAMPTZ NOT NULL DEFAULT (NOW())
    ,picture BYTEA

    ,CONSTRAINT staff_staff_id_pkey PRIMARY KEY (staff_id)
);
ALTER TABLE public.staff ADD CONSTRAINT staff_address_id_fkey FOREIGN KEY (address_id) REFERENCES address (address_id) ON UPDATE CASCADE ON DELETE RESTRICT;
ALTER TABLE public.staff ADD CONSTRAINT staff_store_id_fkey FOREIGN KEY (store_id) REFERENCES store (store_id);`

const STAFF_MySQL = `CREATE TABLE db.staff (
    staff_id INT AUTO_INCREMENT
    ,first_name VARCHAR(45) NOT NULL
    ,last_name VARCHAR(45) NOT NULL
    ,address_id INT NOT NULL
    ,email VARCHAR(50)
    ,store_id INT
    ,active BOOLEAN NOT NULL DEFAULT (TRUE)
    ,username VARCHAR(16) NOT NULL
    ,password VARCHAR(40)
    ,last_update TIMESTAMP NOT NULL DEFAULT (CURRENT_TIMESTAMP) ON UPDATE CURRENT_TIMESTAMP
    ,picture BLOB

    ,CONSTRAINT staff_staff_id_pkey PRIMARY KEY (staff_id)
);
ALTER TABLE db.staff ADD CONSTRAINT staff_address_id_fkey FOREIGN KEY (address_id) REFERENCES address (address_id) ON UPDATE CASCADE ON DELETE RESTRICT;
ALTER TABLE db.staff ADD CONSTRAINT staff_store_id_fkey FOREIGN KEY (store_id) REFERENCES store (store_id);`

func NEW_STORE(dialect, alias string) STORE {
	var tbl STORE
	switch dialect {
	case sq.DialectPostgres:
		tbl.GenericTable.TableSchema = "public"
	case sq.DialectMySQL:
		tbl.GenericTable.TableSchema = "db"
	}
	_ = sq.ReflectTable(&tbl, alias)
	return tbl
}

type STORE struct {
	sq.GenericTable
	STORE_ID         sq.NumberField `ddl:"type=INTEGER primarykey"`
	MANAGER_STAFF_ID sq.NumberField `ddl:"notnull references={staff.staff_id onupdate=cascade ondelete=restrict} index={. unique}"`
	ADDRESS_ID       sq.NumberField `ddl:"notnull references={address.address_id onupdate=cascade ondelete=restrict}"`
	LAST_UPDATE      sq.TimeField   `ddl:"default=DATETIME('now') notnull"`
}

func (tbl STORE) DDL(dialect string, t *T) {
	switch dialect {
	case sq.DialectPostgres:
		t.Column(tbl.STORE_ID).Type("INT").Identity()
		t.Column(tbl.LAST_UPDATE).Type("TIMESTAMPTZ").Default("NOW()")
	case sq.DialectMySQL:
		t.Column(tbl.STORE_ID).Type("INT").Autoincrement()
		t.Column(tbl.LAST_UPDATE).Type("TIMESTAMP").Default("CURRENT_TIMESTAMP").OnUpdateCurrentTimestamp()
	}
}

const STORE_SQLite = `CREATE TABLE store (
    store_id INTEGER PRIMARY KEY
    ,manager_staff_id INT NOT NULL
    ,address_id INT NOT NULL
    ,last_update DATETIME NOT NULL DEFAULT (DATETIME('now'))

    ,CONSTRAINT store_manager_staff_id_fkey FOREIGN KEY (manager_staff_id) REFERENCES staff (staff_id) ON UPDATE CASCADE ON DELETE RESTRICT
    ,CONSTRAINT store_address_id_fkey FOREIGN KEY (address_id) REFERENCES address (address_id) ON UPDATE CASCADE ON DELETE RESTRICT
);
CREATE UNIQUE INDEX store_manager_staff_id_idx ON store (manager_staff_id);`

const STORE_Postgres = `CREATE TABLE public.store (
    store_id INT GENERATED BY DEFAULT AS IDENTITY
    ,manager_staff_id INT NOT NULL
    ,address_id INT NOT NULL
    ,last_update TIMESTAMPTZ NOT NULL DEFAULT (NOW())

    ,CONSTRAINT store_store_id_pkey PRIMARY KEY (store_id)
);
ALTER TABLE public.store ADD CONSTRAINT store_manager_staff_id_fkey FOREIGN KEY (manager_staff_id) REFERENCES staff (staff_id) ON UPDATE CASCADE ON DELETE RESTRICT;
ALTER TABLE public.store ADD CONSTRAINT store_address_id_fkey FOREIGN KEY (address_id) REFERENCES address (address_id) ON UPDATE CASCADE ON DELETE RESTRICT;
CREATE UNIQUE INDEX store_manager_staff_id_idx ON public.store (manager_staff_id);`

const STORE_MySQL = `CREATE TABLE db.store (
    store_id INT AUTO_INCREMENT
    ,manager_staff_id INT NOT NULL
    ,address_id INT NOT NULL
    ,last_update TIMESTAMP NOT NULL DEFAULT (CURRENT_TIMESTAMP) ON UPDATE CURRENT_TIMESTAMP

    ,CONSTRAINT store_store_id_pkey PRIMARY KEY (store_id)
);
ALTER TABLE db.store ADD CONSTRAINT store_manager_staff_id_fkey FOREIGN KEY (manager_staff_id) REFERENCES staff (staff_id) ON UPDATE CASCADE ON DELETE RESTRICT;
ALTER TABLE db.store ADD CONSTRAINT store_address_id_fkey FOREIGN KEY (address_id) REFERENCES address (address_id) ON UPDATE CASCADE ON DELETE RESTRICT;
CREATE UNIQUE INDEX store_manager_staff_id_idx ON db.store (manager_staff_id);`

func NEW_CUSTOMER(dialect, alias string) CUSTOMER {
	var tbl CUSTOMER
	switch dialect {
	case sq.DialectPostgres:
		tbl.GenericTable.TableSchema = "public"
	case sq.DialectMySQL:
		tbl.GenericTable.TableSchema = "db"
	}
	_ = sq.ReflectTable(&tbl, alias)
	return tbl
}

type CUSTOMER struct {
	sq.GenericTable `sq:"name=customer" ddl:"unique={. cols=email,first_name,last_name}"`
	CUSTOMER_ID     sq.NumberField  `ddl:"type=INTEGER primarykey"`
	STORE_ID        sq.NumberField  `ddl:"notnull index"`
	FIRST_NAME      sq.StringField  `ddl:"notnull"`
	LAST_NAME       sq.StringField  `ddl:"notnull index"`
	EMAIL           sq.StringField  `ddl:"unique"`
	ADDRESS_ID      sq.NumberField  `ddl:"notnull references={address onupdate=cascade ondelete=restrict} index"`
	ACTIVE          sq.BooleanField `ddl:"default=TRUE notnull"`
	DATA            sq.JSONField
	CREATE_DATE     sq.TimeField `ddl:"default=DATETIME('now') notnull"`
	LAST_UPDATE     sq.TimeField `ddl:"default=DATETIME('now')"`
}

func (tbl CUSTOMER) DDL(dialect string, t *T) {
	switch dialect {
	case sq.DialectPostgres:
		t.Column(tbl.CUSTOMER_ID).Type("INT").Identity()
		t.Column(tbl.CREATE_DATE).Type("TIMESTAMPTZ").Default("NOW()")
		t.Column(tbl.LAST_UPDATE).Type("TIMESTAMPTZ").Default("NOW()")
	case sq.DialectMySQL:
		t.Column(tbl.CUSTOMER_ID).Type("INT").Autoincrement()
		t.Column(tbl.FIRST_NAME).Type("VARCHAR(45)")
		t.Column(tbl.LAST_NAME).Type("VARCHAR(45)")
		t.Column(tbl.EMAIL).Type("VARCHAR(50)")
		t.Column(tbl.CREATE_DATE).Type("TIMESTAMP").Default("CURRENT_TIMESTAMP")
		t.Column(tbl.LAST_UPDATE).Type("TIMESTAMP").Default("CURRENT_TIMESTAMP").OnUpdateCurrentTimestamp()
	}
}

const CUSTOMER_SQLite = `CREATE TABLE customer (
    customer_id INTEGER PRIMARY KEY
    ,store_id INT NOT NULL
    ,first_name TEXT NOT NULL
    ,last_name TEXT NOT NULL
    ,email TEXT
    ,address_id INT NOT NULL
    ,active BOOLEAN NOT NULL DEFAULT (TRUE)
    ,data JSON
    ,create_date DATETIME NOT NULL DEFAULT (DATETIME('now'))
    ,last_update DATETIME DEFAULT (DATETIME('now'))

    ,CONSTRAINT customer_email_first_name_last_name_key UNIQUE (email, first_name, last_name)
    ,CONSTRAINT customer_email_key UNIQUE (email)
    ,CONSTRAINT customer_address_id_fkey FOREIGN KEY (address_id) REFERENCES address ON UPDATE CASCADE ON DELETE RESTRICT
);
CREATE INDEX customer_store_id_idx ON customer (store_id);
CREATE INDEX customer_last_name_idx ON customer (last_name);
CREATE INDEX customer_address_id_idx ON customer (address_id);`

const CUSTOMER_Postgres = `CREATE TABLE public.customer (
    customer_id INT GENERATED BY DEFAULT AS IDENTITY
    ,store_id INT NOT NULL
    ,first_name TEXT NOT NULL
    ,last_name TEXT NOT NULL
    ,email TEXT
    ,address_id INT NOT NULL
    ,active BOOLEAN NOT NULL DEFAULT (TRUE)
    ,data JSONB
    ,create_date TIMESTAMPTZ NOT NULL DEFAULT (NOW())
    ,last_update TIMESTAMPTZ DEFAULT (NOW())

    ,CONSTRAINT customer_email_first_name_last_name_key UNIQUE (email, first_name, last_name)
    ,CONSTRAINT customer_customer_id_pkey PRIMARY KEY (customer_id)
    ,CONSTRAINT customer_email_key UNIQUE (email)
);
ALTER TABLE public.customer ADD CONSTRAINT customer_address_id_fkey FOREIGN KEY (address_id) REFERENCES address ON UPDATE CASCADE ON DELETE RESTRICT;
CREATE INDEX customer_store_id_idx ON public.customer (store_id);
CREATE INDEX customer_last_name_idx ON public.customer (last_name);
CREATE INDEX customer_address_id_idx ON public.customer (address_id);`

const CUSTOMER_MySQL = `CREATE TABLE db.customer (
    customer_id INT AUTO_INCREMENT
    ,store_id INT NOT NULL
    ,first_name VARCHAR(45) NOT NULL
    ,last_name VARCHAR(45) NOT NULL
    ,email VARCHAR(50)
    ,address_id INT NOT NULL
    ,active BOOLEAN NOT NULL DEFAULT (TRUE)
    ,data JSON
    ,create_date TIMESTAMP NOT NULL DEFAULT (CURRENT_TIMESTAMP)
    ,last_update TIMESTAMP DEFAULT (CURRENT_TIMESTAMP) ON UPDATE CURRENT_TIMESTAMP

    ,CONSTRAINT customer_email_first_name_last_name_key UNIQUE (email, first_name, last_name)
    ,CONSTRAINT customer_customer_id_pkey PRIMARY KEY (customer_id)
    ,CONSTRAINT customer_email_key UNIQUE (email)
);
ALTER TABLE db.customer ADD CONSTRAINT customer_address_id_fkey FOREIGN KEY (address_id) REFERENCES address ON UPDATE CASCADE ON DELETE RESTRICT;
CREATE INDEX customer_store_id_idx ON db.customer (store_id);
CREATE INDEX customer_last_name_idx ON db.customer (last_name);
CREATE INDEX customer_address_id_idx ON db.customer (address_id);`

func NEW_INVENTORY(dialect, alias string) INVENTORY {
	var tbl INVENTORY
	switch dialect {
	case sq.DialectPostgres:
		tbl.GenericTable.TableSchema = "public"
	case sq.DialectMySQL:
		tbl.GenericTable.TableSchema = "db"
	}
	_ = sq.ReflectTable(&tbl, alias)
	return tbl
}

type INVENTORY struct {
	sq.GenericTable `sq:"name=inventory" ddl:"index={. cols=store_id,film_id}"`
	INVENTORY_ID    sq.NumberField `ddl:"type=INTEGER primarykey"`
	FILM_ID         sq.NumberField `ddl:"notnull references={film onupdate=cascade ondelete=restrict}"`
	STORE_ID        sq.NumberField `ddl:"notnull references={store onupdate=cascade ondelete=restrict}"`
	LAST_UPDATE     sq.TimeField   `ddl:"default=DATETIME('now') notnull"`
}

func (tbl INVENTORY) DDL(dialect string, t *T) {
	switch dialect {
	case sq.DialectPostgres:
		t.Column(tbl.INVENTORY_ID).Type("INT").Identity()
		t.Column(tbl.LAST_UPDATE).Type("TIMESTAMPTZ").Default("NOW()")
	case sq.DialectMySQL:
		t.Column(tbl.INVENTORY_ID).Type("INT").Autoincrement()
		t.Column(tbl.LAST_UPDATE).Type("TIMESTAMP").Default("CURRENT_TIMESTAMP").OnUpdateCurrentTimestamp()
	}
}

const INVENTORY_SQLite = `CREATE TABLE inventory (
    inventory_id INTEGER PRIMARY KEY
    ,film_id INT NOT NULL
    ,store_id INT NOT NULL
    ,last_update DATETIME NOT NULL DEFAULT (DATETIME('now'))

    ,CONSTRAINT inventory_film_id_fkey FOREIGN KEY (film_id) REFERENCES film ON UPDATE CASCADE ON DELETE RESTRICT
    ,CONSTRAINT inventory_store_id_fkey FOREIGN KEY (store_id) REFERENCES store ON UPDATE CASCADE ON DELETE RESTRICT
);
CREATE INDEX inventory_store_id_film_id_idx ON inventory (store_id, film_id);`

const INVENTORY_Postgres = `CREATE TABLE public.inventory (
    inventory_id INT GENERATED BY DEFAULT AS IDENTITY
    ,film_id INT NOT NULL
    ,store_id INT NOT NULL
    ,last_update TIMESTAMPTZ NOT NULL DEFAULT (NOW())

    ,CONSTRAINT inventory_inventory_id_pkey PRIMARY KEY (inventory_id)
);
ALTER TABLE public.inventory ADD CONSTRAINT inventory_film_id_fkey FOREIGN KEY (film_id) REFERENCES film ON UPDATE CASCADE ON DELETE RESTRICT;
ALTER TABLE public.inventory ADD CONSTRAINT inventory_store_id_fkey FOREIGN KEY (store_id) REFERENCES store ON UPDATE CASCADE ON DELETE RESTRICT;
CREATE INDEX inventory_store_id_film_id_idx ON public.inventory (store_id, film_id);`

const INVENTORY_MySQL = `CREATE TABLE db.inventory (
    inventory_id INT AUTO_INCREMENT
    ,film_id INT NOT NULL
    ,store_id INT NOT NULL
    ,last_update TIMESTAMP NOT NULL DEFAULT (CURRENT_TIMESTAMP) ON UPDATE CURRENT_TIMESTAMP

    ,CONSTRAINT inventory_inventory_id_pkey PRIMARY KEY (inventory_id)
);
ALTER TABLE db.inventory ADD CONSTRAINT inventory_film_id_fkey FOREIGN KEY (film_id) REFERENCES film ON UPDATE CASCADE ON DELETE RESTRICT;
ALTER TABLE db.inventory ADD CONSTRAINT inventory_store_id_fkey FOREIGN KEY (store_id) REFERENCES store ON UPDATE CASCADE ON DELETE RESTRICT;
CREATE INDEX inventory_store_id_film_id_idx ON db.inventory (store_id, film_id);`

func NEW_RENTAL(dialect, alias string) RENTAL {
	var tbl RENTAL
	switch dialect {
	case sq.DialectPostgres:
		tbl.GenericTable.TableSchema = "public"
	case sq.DialectMySQL:
		tbl.GenericTable.TableSchema = "db"
	}
	_ = sq.ReflectTable(&tbl, alias)
	return tbl
}

type RENTAL struct {
	sq.GenericTable `ddl:"index={. cols=rental_date,inventory_id,customer_id unique}"`
	RENTAL_ID       sq.NumberField `ddl:"type=INTEGER primarykey"`
	RENTAL_DATE     sq.TimeField   `ddl:"notnull"`
	INVENTORY_ID    sq.NumberField `ddl:"notnull index references={inventory onupdate=cascade ondelete=restrict}"`
	CUSTOMER_ID     sq.NumberField `ddl:"notnull index references={customer onupdate=cascade ondelete=restrict}"`
	RETURN_DATE     sq.TimeField
	STAFF_ID        sq.NumberField `ddl:"notnull index references={staff onupdate=cascade ondelete=restrict}"`
	LAST_UPDATE     sq.TimeField   `ddl:"default=DATETIME('now') notnull"`
}

func (tbl RENTAL) DDL(dialect string, t *T) {
	switch dialect {
	case sq.DialectPostgres:
		t.Column(tbl.RENTAL_ID).Type("INT").Identity()
		t.Column(tbl.RETURN_DATE).Type("TIMESTAMPTZ")
		t.Column(tbl.LAST_UPDATE).Type("TIMESTAMPTZ").Default("NOW()")
	case sq.DialectMySQL:
		t.Column(tbl.RENTAL_ID).Type("INT").Autoincrement()
		t.Column(tbl.RETURN_DATE).Type("TIMESTAMP")
		t.Column(tbl.LAST_UPDATE).Type("TIMESTAMP").Default("CURRENT_TIMESTAMP").OnUpdateCurrentTimestamp()
	}
}

const RENTAL_SQLite = `CREATE TABLE rental (
    rental_id INTEGER PRIMARY KEY
    ,rental_date DATETIME NOT NULL
    ,inventory_id INT NOT NULL
    ,customer_id INT NOT NULL
    ,return_date DATETIME
    ,staff_id INT NOT NULL
    ,last_update DATETIME NOT NULL DEFAULT (DATETIME('now'))

    ,CONSTRAINT rental_inventory_id_fkey FOREIGN KEY (inventory_id) REFERENCES inventory ON UPDATE CASCADE ON DELETE RESTRICT
    ,CONSTRAINT rental_customer_id_fkey FOREIGN KEY (customer_id) REFERENCES customer ON UPDATE CASCADE ON DELETE RESTRICT
    ,CONSTRAINT rental_staff_id_fkey FOREIGN KEY (staff_id) REFERENCES staff ON UPDATE CASCADE ON DELETE RESTRICT
);
CREATE UNIQUE INDEX rental_rental_date_inventory_id_customer_id_idx ON rental (rental_date, inventory_id, customer_id);
CREATE INDEX rental_inventory_id_idx ON rental (inventory_id);
CREATE INDEX rental_customer_id_idx ON rental (customer_id);
CREATE INDEX rental_staff_id_idx ON rental (staff_id);`

const RENTAL_Postgres = `CREATE TABLE public.rental (
    rental_id INT GENERATED BY DEFAULT AS IDENTITY
    ,rental_date TIMESTAMPTZ NOT NULL
    ,inventory_id INT NOT NULL
    ,customer_id INT NOT NULL
    ,return_date TIMESTAMPTZ
    ,staff_id INT NOT NULL
    ,last_update TIMESTAMPTZ NOT NULL DEFAULT (NOW())

    ,CONSTRAINT rental_rental_id_pkey PRIMARY KEY (rental_id)
);
ALTER TABLE public.rental ADD CONSTRAINT rental_inventory_id_fkey FOREIGN KEY (inventory_id) REFERENCES inventory ON UPDATE CASCADE ON DELETE RESTRICT;
ALTER TABLE public.rental ADD CONSTRAINT rental_customer_id_fkey FOREIGN KEY (customer_id) REFERENCES customer ON UPDATE CASCADE ON DELETE RESTRICT;
ALTER TABLE public.rental ADD CONSTRAINT rental_staff_id_fkey FOREIGN KEY (staff_id) REFERENCES staff ON UPDATE CASCADE ON DELETE RESTRICT;
CREATE UNIQUE INDEX rental_rental_date_inventory_id_customer_id_idx ON public.rental (rental_date, inventory_id, customer_id);
CREATE INDEX rental_inventory_id_idx ON public.rental (inventory_id);
CREATE INDEX rental_customer_id_idx ON public.rental (customer_id);
CREATE INDEX rental_staff_id_idx ON public.rental (staff_id);`

const RENTAL_MySQL = `CREATE TABLE db.rental (
    rental_id INT AUTO_INCREMENT
    ,rental_date DATETIME NOT NULL
    ,inventory_id INT NOT NULL
    ,customer_id INT NOT NULL
    ,return_date TIMESTAMP
    ,staff_id INT NOT NULL
    ,last_update TIMESTAMP NOT NULL DEFAULT (CURRENT_TIMESTAMP) ON UPDATE CURRENT_TIMESTAMP

    ,CONSTRAINT rental_rental_id_pkey PRIMARY KEY (rental_id)
);
ALTER TABLE db.rental ADD CONSTRAINT rental_inventory_id_fkey FOREIGN KEY (inventory_id) REFERENCES inventory ON UPDATE CASCADE ON DELETE RESTRICT;
ALTER TABLE db.rental ADD CONSTRAINT rental_customer_id_fkey FOREIGN KEY (customer_id) REFERENCES customer ON UPDATE CASCADE ON DELETE RESTRICT;
ALTER TABLE db.rental ADD CONSTRAINT rental_staff_id_fkey FOREIGN KEY (staff_id) REFERENCES staff ON UPDATE CASCADE ON DELETE RESTRICT;
CREATE UNIQUE INDEX rental_rental_date_inventory_id_customer_id_idx ON db.rental (rental_date, inventory_id, customer_id);
CREATE INDEX rental_inventory_id_idx ON db.rental (inventory_id);
CREATE INDEX rental_customer_id_idx ON db.rental (customer_id);
CREATE INDEX rental_staff_id_idx ON db.rental (staff_id);`

func NEW_PAYMENT(dialect, alias string) PAYMENT {
	var tbl PAYMENT
	switch dialect {
	case sq.DialectPostgres:
		tbl.GenericTable.TableSchema = "public"
	case sq.DialectMySQL:
		tbl.GenericTable.TableSchema = "db"
	}
	_ = sq.ReflectTable(&tbl, alias)
	return tbl
}

type PAYMENT struct {
	sq.GenericTable
	PAYMENT_ID   sq.NumberField `ddl:"type=INTEGER primarykey"`
	CUSTOMER_ID  sq.NumberField `ddl:"notnull index references={customer onupdate=cascade ondelete=restrict}"`
	STAFF_ID     sq.NumberField `ddl:"notnull index references={staff onupdate=cascade ondelete=restrict}"`
	RENTAL_ID    sq.NumberField `ddl:"references={rental onupdate=cascade ondelete=restrict}"`
	AMOUNT       sq.NumberField `ddl:"type=DECIMAL(5,2) notnull"`
	PAYMENT_DATE sq.TimeField   `ddl:"notnull"`
}

func (tbl PAYMENT) DDL(dialect string, t *T) {
	switch dialect {
	case sq.DialectPostgres:
		t.Column(tbl.PAYMENT_ID).Type("INT").Identity()
		t.Column(tbl.PAYMENT_DATE).Type("TIMESTAMPTZ")
	case sq.DialectMySQL:
		t.Column(tbl.PAYMENT_ID).Type("INT").Autoincrement()
		t.Column(tbl.PAYMENT_DATE).Type("TIMESTAMP")
	}
}

const PAYMENT_SQLite = `CREATE TABLE payment (
    payment_id INTEGER PRIMARY KEY
    ,customer_id INT NOT NULL
    ,staff_id INT NOT NULL
    ,rental_id INT
    ,amount DECIMAL(5,2) NOT NULL
    ,payment_date DATETIME NOT NULL

    ,CONSTRAINT payment_customer_id_fkey FOREIGN KEY (customer_id) REFERENCES customer ON UPDATE CASCADE ON DELETE RESTRICT
    ,CONSTRAINT payment_staff_id_fkey FOREIGN KEY (staff_id) REFERENCES staff ON UPDATE CASCADE ON DELETE RESTRICT
    ,CONSTRAINT payment_rental_id_fkey FOREIGN KEY (rental_id) REFERENCES rental ON UPDATE CASCADE ON DELETE RESTRICT
);
CREATE INDEX payment_customer_id_idx ON payment (customer_id);
CREATE INDEX payment_staff_id_idx ON payment (staff_id);`

const PAYMENT_Postgres = `CREATE TABLE public.payment (
    payment_id INT GENERATED BY DEFAULT AS IDENTITY
    ,customer_id INT NOT NULL
    ,staff_id INT NOT NULL
    ,rental_id INT
    ,amount DECIMAL(5,2) NOT NULL
    ,payment_date TIMESTAMPTZ NOT NULL

    ,CONSTRAINT payment_payment_id_pkey PRIMARY KEY (payment_id)
);
ALTER TABLE public.payment ADD CONSTRAINT payment_customer_id_fkey FOREIGN KEY (customer_id) REFERENCES customer ON UPDATE CASCADE ON DELETE RESTRICT;
ALTER TABLE public.payment ADD CONSTRAINT payment_staff_id_fkey FOREIGN KEY (staff_id) REFERENCES staff ON UPDATE CASCADE ON DELETE RESTRICT;
ALTER TABLE public.payment ADD CONSTRAINT payment_rental_id_fkey FOREIGN KEY (rental_id) REFERENCES rental ON UPDATE CASCADE ON DELETE RESTRICT;
CREATE INDEX payment_customer_id_idx ON public.payment (customer_id);
CREATE INDEX payment_staff_id_idx ON public.payment (staff_id);`

const PAYMENT_MySQL = `CREATE TABLE db.payment (
    payment_id INT AUTO_INCREMENT
    ,customer_id INT NOT NULL
    ,staff_id INT NOT NULL
    ,rental_id INT
    ,amount DECIMAL(5,2) NOT NULL
    ,payment_date TIMESTAMP NOT NULL

    ,CONSTRAINT payment_payment_id_pkey PRIMARY KEY (payment_id)
);
ALTER TABLE db.payment ADD CONSTRAINT payment_customer_id_fkey FOREIGN KEY (customer_id) REFERENCES customer ON UPDATE CASCADE ON DELETE RESTRICT;
ALTER TABLE db.payment ADD CONSTRAINT payment_staff_id_fkey FOREIGN KEY (staff_id) REFERENCES staff ON UPDATE CASCADE ON DELETE RESTRICT;
ALTER TABLE db.payment ADD CONSTRAINT payment_rental_id_fkey FOREIGN KEY (rental_id) REFERENCES rental ON UPDATE CASCADE ON DELETE RESTRICT;
CREATE INDEX payment_customer_id_idx ON db.payment (customer_id);
CREATE INDEX payment_staff_id_idx ON db.payment (staff_id);`

func NEW_DUMMY_TABLE(dialect, alias string) DUMMY_TABLE {
	var tbl DUMMY_TABLE
	switch dialect {
	case sq.DialectPostgres:
		tbl.GenericTable.TableSchema = "public"
	case sq.DialectMySQL:
		tbl.GenericTable.TableSchema = "db"
	}
	_ = sq.ReflectTable(&tbl, alias)
	return tbl
}

type DUMMY_TABLE struct {
	sq.GenericTable `ddl:"primarykey={. cols=id1,id2} unique={. cols=score,color}"`
	ID1             sq.NumberField
	ID2             sq.StringField
	SCORE           sq.NumberField
	COLOR           sq.StringField `ddl:"collate=nocase default='red'"`
	DATA            sq.JSONField
}

func (tbl DUMMY_TABLE) DDL(dialect string, t *T) {
	const indexName = "dummy_table_complex_expr_idx"
	switch dialect {
	case sq.DialectPostgres:
		t.Column(tbl.COLOR).Collate("C")
		t.NameIndex(indexName,
			tbl.SCORE,
			sq.Fieldf("SUBSTR({}, 1, 2)", tbl.COLOR),
			sq.Fieldf("{} || {}", tbl.COLOR, " abcd"),
			sq.Fieldf("({}->>{})::INT", tbl.DATA, "age"),
		).Where("{} = {}", tbl.COLOR, "red")
	case sq.DialectMySQL:
		t.Column(tbl.COLOR).Type("VARCHAR(50)").Collate("latin_swedish_ci")
		t.NameIndex(indexName,
			tbl.SCORE,
			sq.Fieldf("SUBSTR({}, 1, 2)", tbl.COLOR),
			sq.Fieldf("CONCAT({}, {})", tbl.COLOR, " abcd"),
			sq.Fieldf("CAST({}->>{} AS SIGNED)", tbl.DATA, "$.age"),
		)
	case sq.DialectSQLite:
		t.Column(tbl.COLOR).Collate("nocase")
		t.NameIndex(indexName,
			tbl.SCORE,
			sq.Fieldf("SUBSTR({}, 1, 2)", tbl.COLOR),
			sq.Fieldf("{} || {}", tbl.COLOR, " abcd"),
			sq.Fieldf("CAST(JSON_EXTRACT({}, {}) AS INT)", tbl.DATA, "$.age"),
		).Where("{} = {}", tbl.COLOR, "red")
	}
	t.Check("dummy_table_score_positive_check", "{} > 0", tbl.SCORE)
	t.Check("dummy_table_score_id1_greater_than_check", "{} > {}", tbl.SCORE, tbl.ID1)
	t.PrimaryKey(tbl.ID1, tbl.ID2)
	t.Unique(tbl.SCORE, tbl.COLOR)
}

const DUMMY_TABLE_SQLite = `CREATE TABLE dummy_table (
    id1 INT
    ,id2 TEXT
    ,score INT
    ,color TEXT DEFAULT ('red') COLLATE nocase
    ,data JSON

    ,CONSTRAINT dummy_table_id1_id2_pkey PRIMARY KEY (id1, id2)
    ,CONSTRAINT dummy_table_score_color_key UNIQUE (score, color)
    ,CONSTRAINT dummy_table_score_positive_check CHECK (score > 0)
    ,CONSTRAINT dummy_table_score_id1_greater_than_check CHECK (score > id1)
);
CREATE INDEX dummy_table_complex_expr_idx ON dummy_table (score, (SUBSTR(color, 1, 2)), (color || ' abcd'), (CAST(JSON_EXTRACT(data, '$.age') AS INT))) WHERE color = 'red';`

const DUMMY_TABLE_Postgres = `CREATE TABLE public.dummy_table (
    id1 INT
    ,id2 TEXT
    ,score INT
    ,color TEXT DEFAULT ('red') COLLATE "C"
    ,data JSONB

    ,CONSTRAINT dummy_table_id1_id2_pkey PRIMARY KEY (id1, id2)
    ,CONSTRAINT dummy_table_score_color_key UNIQUE (score, color)
    ,CONSTRAINT dummy_table_score_positive_check CHECK (score > 0)
    ,CONSTRAINT dummy_table_score_id1_greater_than_check CHECK (score > id1)
);
CREATE INDEX dummy_table_complex_expr_idx ON public.dummy_table (score, (SUBSTR(color, 1, 2)), (color || ' abcd'), ((data->>'age')::INT)) WHERE color = 'red';`

const DUMMY_TABLE_MySQL = `CREATE TABLE db.dummy_table (
    id1 INT
    ,id2 VARCHAR(255)
    ,score INT
    ,color VARCHAR(50) DEFAULT ('red') COLLATE latin_swedish_ci
    ,data JSON

    ,CONSTRAINT dummy_table_id1_id2_pkey PRIMARY KEY (id1, id2)
    ,CONSTRAINT dummy_table_score_color_key UNIQUE (score, color)
    ,CONSTRAINT dummy_table_score_positive_check CHECK (score > 0)
    ,CONSTRAINT dummy_table_score_id1_greater_than_check CHECK (score > id1)
);
CREATE INDEX dummy_table_complex_expr_idx ON db.dummy_table (score, (SUBSTR(color, 1, 2)), (CONCAT(color, ' abcd')), (CAST(data->>'$.age' AS SIGNED)));`

func NEW_DUMMY_TABLE_2(dialect, alias string) DUMMY_TABLE_2 {
	var tbl DUMMY_TABLE_2
	switch dialect {
	case sq.DialectPostgres:
		tbl.GenericTable.TableSchema = "public"
	case sq.DialectMySQL:
		tbl.GenericTable.TableSchema = "db"
	}
	_ = sq.ReflectTable(&tbl, alias)
	return tbl
}

type DUMMY_TABLE_2 struct {
	sq.GenericTable `ddl:"references={dummy_table.id1,id2 cols=id1,id2 onupdate=cascade ondelete=restrict}"`
	ID1 sq.NumberField
	ID2 sq.StringField
}

func (tbl DUMMY_TABLE_2) DDL(dialect string, t *T) {
	ref := NEW_DUMMY_TABLE(dialect, "")
	switch dialect {
	case sq.DialectPostgres, sq.DialectMySQL:
		t.ForeignKey(tbl.ID1, tbl.ID2).References(ref, ref.ID1, ref.ID2).OnUpdate("CASCADE").OnDelete("RESTRICT")
	}
}

const DUMMY_TABLE_2_SQLite = `CREATE TABLE dummy_table_2 (
    id1 INT
    ,id2 TEXT

    ,CONSTRAINT dummy_table_2_id1_id2_fkey FOREIGN KEY (id1, id2) REFERENCES dummy_table (id1, id2) ON UPDATE CASCADE ON DELETE RESTRICT
);`

const DUMMY_TABLE_2_Postgres = `CREATE TABLE public.dummy_table_2 (
    id1 INT
    ,id2 TEXT
);
ALTER TABLE public.dummy_table_2 ADD CONSTRAINT dummy_table_2_id1_id2_fkey FOREIGN KEY (id1, id2) REFERENCES dummy_table (id1, id2) ON UPDATE CASCADE ON DELETE RESTRICT;`

const DUMMY_TABLE_2_MySQL = `CREATE TABLE db.dummy_table_2 (
    id1 INT
    ,id2 VARCHAR(255)
);
ALTER TABLE db.dummy_table_2 ADD CONSTRAINT dummy_table_2_id1_id2_fkey FOREIGN KEY (id1, id2) REFERENCES dummy_table (id1, id2) ON UPDATE CASCADE ON DELETE RESTRICT;`
