ddl.go
column.go | constraint.go | index.go
fmt.go
trigger.go | function.go
table.go
view.go
v.go | t.go
schema.go
introspect.go
catalog.go
migration_commands.go

type Migration struct {
    Dialect string
    CreateSchemas []CreateSchemaCommand
    CreateExtensions []CreateExtensionCommand
    // CreateEnums goes here
    CreateFunctions []CreateFunctionCommand
    CreateTables []CreateTableCommand
    AlterTables []AlterTableCommand // add column | alter column | add constraint
    CreateViews []CreateViewCommand
    CreateIndexes []CreateIndexCommand
    CreateTriggers []CreateTriggerCommand
    CreateForeignKeys []AlterTableCommand
    DropViews []DropViewCommand
    DropTables []DropTableCommand
    DropTriggers []DropTriggerCommand
    DropIndexes []DropIndexCommand
    DropConstraints []DropConstraintCommand
    DropColumns []DropColumnCommand
    DropFunctions []DropFunctionCommand
    // DropEnums goes here
    DropExtensions []DropExtensionCommand
}
remove unused commands (e.g. the RenameX commands)
if we're looping over value structs, there should be an 'Ignore' field in each
Command so that the user can nullify a command without resorting to subslicing
tricks. For example, if they want to blot out all index commands on a certain
table (loop over each index command, set the ignore flag where necessary)

bah gawd. types. domains. enums.
ALSO: functions may be user-defined aggregate functions or user-defined windows

// pass a tx in explicitly to run everything in a transaction

001.up.sql
001.down.sql
002.manual-transaction.up.sql
002.down.sql
migration_name | started_at | ended_at | error_msg
index (migration_name)
index (migration_name, started_at, ended_at)

if the user eventually wants to expose the sq.Query by a DDLView, I can add a
function just for that.
func GetDDLViewQuery(ddlView DDLView) sq.Query

consider adding ability to tag constraints, indexes, triggers, views, functions
with a versionID. This would open the path for automatically dropping and
recreating them if the versionID changes.
