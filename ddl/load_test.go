package ddl

import (
	"bytes"
	"fmt"
	"testing"

	"github.com/bokwoon95/sq"
	"github.com/bokwoon95/testutil"
)

func Test_Load_ACTOR(t *testing.T) {

	t.Run("SQLite", func(t *testing.T) {
		const dialect = sq.DialectSQLite
		is := testutil.New(t, testutil.FailFast)
		buf := bufpool.Get().(*bytes.Buffer)
		defer func() {
			buf.Reset()
			bufpool.Put(buf)
		}()
		var m Metadata
		err := m.LoadTable(NEW_ACTOR(dialect, ""))
		is.NoErr(err)
		table := m.Schemas[0].Tables[0]
		str, err := CreateTable(dialect, table)
		is.NoErr(err)
		buf.WriteString(str)
		for _, index := range table.Indices {
			buf.WriteString("\n")
			str, err := CreateIndex(dialect, index)
			is.NoErr(err)
			buf.WriteString(str)
		}
		const wantDDL = `CREATE TABLE actor (
    actor_id INTEGER
    ,first_name VARCHAR(255) NOT NULL
    ,last_name VARCHAR(255) NOT NULL
    ,full_name VARCHAR(255) GENERATED ALWAYS AS (first_name || ' ' || last_name) VIRTUAL
    ,full_name_reversed VARCHAR(255) GENERATED ALWAYS AS (last_name || ' ' || first_name) STORED
    ,last_update DATETIME NOT NULL DEFAULT (DATETIME('now'))

    ,CONSTRAINT actor_actor_id_pkey PRIMARY KEY (actor_id)
);
CREATE INDEX actor_last_name_idx ON actor (last_name);`
		is.Equal(wantDDL, buf.String())
	})

	t.Run("Postgres", func(t *testing.T) {
		const dialect = sq.DialectPostgres
		is := testutil.New(t, testutil.FailFast)
		buf := bufpool.Get().(*bytes.Buffer)
		defer func() {
			buf.Reset()
			bufpool.Put(buf)
		}()
		m := NewMetadata(dialect)
		err := m.LoadTable(NEW_ACTOR(dialect, ""))
		is.NoErr(err)
		table := m.Schemas[0].Tables[0]
		str, err := CreateTable(dialect, table)
		is.NoErr(err)
		buf.WriteString(str)
		for _, constraint := range table.Constraints {
			buf.WriteString("\n")
			str, err := CreateConstraint(dialect, constraint)
			is.NoErr(err)
			buf.WriteString(str)
		}
		for _, index := range table.Indices {
			buf.WriteString("\n")
			str, err := CreateIndex(dialect, index)
			is.NoErr(err)
			buf.WriteString(str)
		}
		const wantDDL = `CREATE TABLE public.actor (
    actor_id INTEGER GENERATED BY DEFAULT AS IDENTITY
    ,first_name TEXT NOT NULL
    ,last_name TEXT NOT NULL
    ,full_name TEXT GENERATED ALWAYS AS (first_name || ' ' || last_name) STORED
    ,full_name_reversed TEXT GENERATED ALWAYS AS (last_name || ' ' || first_name) STORED
    ,last_update TIMESTAMPTZ NOT NULL DEFAULT (NOW())
);
ALTER TABLE public.actor ADD CONSTRAINT actor_actor_id_pkey PRIMARY KEY (actor_id);
CREATE INDEX actor_last_name_idx ON public.actor (last_name);`
		is.Equal(wantDDL, buf.String())
	})
}

func Test_LoadTable_SQLite(t *testing.T) {
	const dialect = sq.DialectSQLite
	is := testutil.New(t)
	tables := []sq.Table{
		NEW_ACTOR(dialect, ""),
		NEW_CATEGORY(dialect, ""),
		NEW_COUNTRY(dialect, ""),
		NEW_CITY(dialect, ""),
		NEW_ADDRESS(dialect, ""),
		NEW_LANGUAGE(dialect, ""),
		NEW_FILM(dialect, ""),
		NEW_FILM_TEXT(dialect, ""),
		NEW_FILM_ACTOR(dialect, ""),
		NEW_FILM_CATEGORY(dialect, ""),
		NEW_STAFF(dialect, ""),
		NEW_STORE(dialect, ""),
		NEW_CUSTOMER(dialect, ""),
		NEW_INVENTORY(dialect, ""),
		NEW_RENTAL(dialect, ""),
		NEW_PAYMENT(dialect, ""),
		NEW_DUMMY_TABLE(dialect, ""),
		NEW_DUMMY_TABLE_2(dialect, ""),
	}
	m := NewMetadata(dialect)
	for _, table := range tables {
		err := m.LoadTable(table)
		is.NoErr(err)
	}
	is.True(len(m.Schemas) > 0)
	for i, table := range m.Schemas[0].Tables {
		if i > 0 {
			fmt.Println()
		}
		str, err := CreateTable(dialect, table)
		is.NoErr(err)
		fmt.Println(str)
		for _, index := range table.Indices {
			fmt.Println()
			str, err := CreateIndex(dialect, index)
			is.NoErr(err)
			fmt.Println(str)
		}
	}
}

func Test_LoadTable_MySQL(t *testing.T) {
	const dialect = sq.DialectMySQL
	is := testutil.New(t)
	tables := []sq.Table{
		NEW_ACTOR(dialect, ""),
		NEW_CATEGORY(dialect, ""),
		NEW_COUNTRY(dialect, ""),
		NEW_CITY(dialect, ""),
		NEW_ADDRESS(dialect, ""),
		NEW_LANGUAGE(dialect, ""),
		NEW_FILM(dialect, ""),
		NEW_FILM_TEXT(dialect, ""),
		NEW_FILM_ACTOR(dialect, ""),
		NEW_FILM_CATEGORY(dialect, ""),
		NEW_STAFF(dialect, ""),
		NEW_STORE(dialect, ""),
		NEW_CUSTOMER(dialect, ""),
		NEW_INVENTORY(dialect, ""),
		NEW_RENTAL(dialect, ""),
		NEW_PAYMENT(dialect, ""),
		NEW_DUMMY_TABLE(dialect, ""),
		NEW_DUMMY_TABLE_2(dialect, ""),
	}
	m := NewMetadata(dialect)
	for _, table := range tables {
		err := m.LoadTable(table)
		is.NoErr(err)
	}
	is.True(len(m.Schemas) > 0)
	for i, table := range m.Schemas[0].Tables {
		if i > 0 {
			fmt.Println()
		}
		str, err := CreateTable(dialect, table)
		is.NoErr(err)
		fmt.Println(str)
		for _, constraint := range table.Constraints {
			fmt.Println()
			str, err := CreateConstraint(dialect, constraint)
			is.NoErr(err)
			fmt.Println(str)
		}
		for _, index := range table.Indices {
			fmt.Println()
			str, err := CreateIndex(dialect, index)
			is.NoErr(err)
			fmt.Println(str)
		}
	}
}

func Test_LoadTable_Postgres(t *testing.T) {
	const dialect = sq.DialectPostgres
	is := testutil.New(t)
	tables := []sq.Table{
		NEW_ACTOR(dialect, ""),
		NEW_CATEGORY(dialect, ""),
		NEW_COUNTRY(dialect, ""),
		NEW_CITY(dialect, ""),
		NEW_ADDRESS(dialect, ""),
		NEW_LANGUAGE(dialect, ""),
		NEW_FILM(dialect, ""),
		NEW_FILM_ACTOR(dialect, ""),
		NEW_FILM_CATEGORY(dialect, ""),
		NEW_STAFF(dialect, ""),
		NEW_STORE(dialect, ""),
		NEW_CUSTOMER(dialect, ""),
		NEW_INVENTORY(dialect, ""),
		NEW_RENTAL(dialect, ""),
		NEW_PAYMENT(dialect, ""),
		NEW_DUMMY_TABLE(dialect, ""),
		NEW_DUMMY_TABLE_2(dialect, ""),
	}
	m := NewMetadata(dialect)
	for _, table := range tables {
		err := m.LoadTable(table)
		is.NoErr(err)
	}
	is.True(len(m.Schemas) > 0)
	for i, table := range m.Schemas[0].Tables {
		if i > 0 {
			fmt.Println()
		}
		str, err := CreateTable(dialect, table)
		is.NoErr(err)
		fmt.Println(str)
		for _, constraint := range table.Constraints {
			fmt.Println()
			str, err := CreateConstraint(dialect, constraint)
			is.NoErr(err)
			fmt.Println(str)
		}
		for _, index := range table.Indices {
			fmt.Println()
			str, err := CreateIndex(dialect, index)
			is.NoErr(err)
			fmt.Println(str)
		}
	}
}
