column.DDL(dialect)
column.DDLFrom(dialect, column2)

type Stmts struct {
    []TableStmts // CREATE TABLE
    []ColumnStmts // ALTER TABLE ADD COLUMN | ALTER TABLE ALTER COLUMN
    []ConstraintStmts // ALTER TABLE ADD CONSTRAINT | ALTER TABLE ALTER CONSTRAINT
    []IndexStmts // CREATE INDEX
    []ViewStmts // CREATE VIEW
    []FunctionStmts // CREATE FUNCTION
    []TriggerStmts // CREATE TRIGGER
}

what table schema? what table name? what (column|constraint|index|view|function|trigger)name?
what operation?
CREATE SCHEMA
CREATE TABLE
ALTER TABLE DROP COLUMN
    NOTE: don't implement DROP COLUMN because columns can contain data. if alter column is not enough (e.g. adding a generated expression), simply return a warning informing the user that generated expressions cannot be retrofitted on columns that already exist.
ALTER TABLE ADD COLUMN
ALTER TABLE ALTER COLUMN
    TYPE
    SET DEFAULT
    DROP DEFAULT
    SET NOT NULL
    DROP NOT NULL
    DROP EXPRESSION
    ADD GENERATED ... IDENTITY
    DROP IDENTITY
DROP INDEX
CREATE INDEX
ALTER TABLE DROP CONSTRAINT
ALTER TABLE ADD CONSTRAINT
DROP VIEW
CREATE OR REPLACE VIEW
DROP FUNCTION
CREATE OR REPLACE FUNCTION

TODO: rename Metadata to Catalog. Include the CatalogName.

Custom SQL-level filtering when retrieving the catalog is possible! Simply ask the user to provide an sq.Predicate which will get appended to the overall query.

DiffMetadata returns a struct containing ddl.Commands
    The ddl.Commands are organized in a way that matches the hierarchy of a Catalog.
    This makes it easy for the user to search for a particular piece of ddl command, e.g they are looking for all CREATE INDEX commands so that they can convert it to CREATE INDEX ... CONCURRENTLY.

unlike columns, constraints may not be harmless if ignored. Old constraints
that are not dropped may actively hinder adding new columns or altering
existing columns. but I have already committed to -NOT- handling the dropping
of constraints or indices in automigrate. How to reconcile?

stmts := ddl.Stmts{}
stmts.AddSchema()
stmts.AddTable()
stmts.AddColumn()
stmts.AddConstraint()
stmts.AddIndex()
stmts.DiffColumn()
stmts.DiffConstraint()
stmts.DiffIndex()

m1, m2 := ddl.NewMetadata(dialect), ddl.NewMetadata(dialect)
err := m1.LoadDB(queryer)
if err != nil {
}
err = m2.LoadTables(tables)
if err != nil {
}
stmts := ddl.Stmts{}
stmts.DiffMetadata()
