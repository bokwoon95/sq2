column.DDL(dialect)
column.DDLFrom(dialect, column2)

type Stmts struct {
    []TableStmts // CREATE TABLE
    []ColumnStmts // ALTER TABLE ADD COLUMN | ALTER TABLE ALTER COLUMN
    []ConstraintStmts // ALTER TABLE ADD CONSTRAINT | ALTER TABLE ALTER CONSTRAINT
    []IndexStmts // CREATE INDEX
    []ViewStmts // CREATE VIEW
    []FunctionStmts // CREATE FUNCTION
    []TriggerStmts // CREATE TRIGGER
}

unlike columns, constraints may not be harmless if ignored. Old constraints
that are not dropped may actively hinder adding new columns or altering
existing columns. but I have already committed to -NOT- handling the dropping
of constraints or indices in automigrate. How to reconcile?

stmts := ddl.Stmts{}
stmts.AddSchema()
stmts.AddTable()
stmts.AddColumn()
stmts.AddConstraint()
stmts.AddIndex()
stmts.DiffColumn()
stmts.DiffConstraint()
stmts.DiffIndex()

m1, m2 := ddl.NewMetadata(dialect), ddl.NewMetadata(dialect)
err := m1.LoadDB(queryer)
if err != nil {
}
err = m2.LoadTables(tables)
if err != nil {
}
stmts := ddl.Stmts{}
stmts.DiffMetadata()
