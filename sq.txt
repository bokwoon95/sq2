sq.go
param.go
fmt.go
predicate.go
rowvalue.go
table_info.go
field_info.go <-> custom_field.go <-> assignment.go
blob_field.go | boolean_field.go | json_field.go | numberfield.go | string_field.go | time_field.go
join_table.go
variadic_query.go
subquery_field.go | cte.go
...
window.go (at very last because nothing depends on it)

sq README needs a FAQ section, just like how Maddy mail server does. I naturally gravitaed towards the FAQ link in order to learn more about maddy, and was able to learn so much it just from reading the FAQ alone.

How much slower is checking before quoting an identifier compared to just quoting it? Need to run some benchmarks, decide if it's worth it.

investigate using type assertion and pointers fro performance:
https://www.reddit.com/r/golang/comments/9xs0r2/why_is_type_assertion_so_fast/
"interface asserted to pointer and pointer assigned to interface are both optimized by gc. For other kinds of types other than pointer, the larger size their values, the slower in assertions and assignments."
type assertions will be used very often during query manipulation (inside a trigger, etc). We want query manipulation to be fast.

investigate using type conversion and alias types for perforance:
https://stackoverflow.com/a/32253871
"converting to and from the underlying type of your custom type does not make a copy if it."
type conversions can be used very often for converting between the XXXField types and FieldInfo, which we want to be fast.

In general, will using struct values instead of struct pointers be faster when building a query? I need to know.

idea: package testx
testx.Diff() will provide coloured character-level diffing (like diff-so-fancy) by parsing the output of cmp.Diff
testx.Diffx() is like Diff(), but accepts variadic cmp.Option arguments
testx.Callers() will print the callers. Colouring not necessary.
    WOW but testx.Callers might break depending on whether you invoke your tests with a TestMain. Could be fixed with a package-level config variable to indicate if you are using TestMain.
Diff() will strictly follow the convention of (got, want). No more ambiguous LHS and RHS. The reasoning is so that the minus sign will be the typical red, which signifies the wrong output. While the plus sign, and the typical green, will be the desired output.

ddl: patches
p := ddl.NewPatches()
p.Register(patchName, patchFunc)
p.RegisterWithGroup(patchName, patchGroup, patchFunc)
p.ApplyAllPatches(db, )
p.ApplyPatches(db, patchNames...)
p.ApplyPatchGroups(db, patchGroups...)
CREATE TABLE sq_patches (
    patch_name VARCHAR(255) -- most database-agnostic type
    started_at BIGINT -- unix timestamp
    ended_at BIGINT -- unix timestamp
    success BOOLEAN
);
started_at, but no ended_at means what?
started_at, ended_at but no success means what?

// TODO: change from (want, got) to (got, want)

IMPORTANT: before I do any kind of performance testing, I need to know:
- given a simple SQL query that instantiates a query, runs it and then exits, does the query get stack allocated?
    - I really need this to happen because it's the main reason why I went with queries as struct values instead of struct pointers
    - If I changed the queries to struct pointers instead, would the allocation/performance change?
- assuming a simple query is stack allocated, if I passed the entire query to LogQueryStats would it change to heap allocation?
    - I need to know this because it determines if I want to pass the Query interface to LogQueryStats for analytics purposes.
    - If LogQueryStats gets the Query interface, it can do interesting things like analyzing which tables and columns were most commonly used
    - But if performance takes a hit compared to just passing in the compiled query string and args, then maybe I'll leave it out

func (TBL) View(dialect string) sq.Query {
    return SQLite.
        Select(fields..).
        From(table).
        Join(table).
        Where(predicates...)
} // what about materialized views and their different refresh configs?
func (TBL) DDL(dialect string, t *T) {
    t.Trigger(name, strings.NewReader(`CREATE TRIGGER ON UPDATE...`))
    t.Trigger(name, t.File(filename)) // if the user didn't pass in an fs.FS, it will panic
    /*
    okay, but there is no way of creating a templated trigger. You have to
    manually keep the columns references in the trigger up to date with
    changes, or the trigger breaks. Is there no way around this?
    */
    /*
    Also, trigger procedures should not be defined in tables. The actual
    attaching of a trigger procedure to a table should be defined in the table,
    but the trigger source must be defined outside because Postgres allows the
    same trigger procedure to be reused across multiple tables. But where to
    hook this in?
    */
}
