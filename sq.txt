sq.go
param.go
fmt.go
predicate.go
rowvalue.go
table_info.go
field_info.go <-> custom_field.go <-> assignment.go
blob_field.go | boolean_field.go | json_field.go | numberfield.go | string_field.go | time_field.go
join_table.go
variadic_query.go
subquery_field.go | cte.go
...
window.go (at very last because nothing depends on it)

queries to test:
- SELECT
- SELECT DISTINCT
- SELECT DISTINCT ON
- SELECT EXISTS
- INSERT last_insert_id
- INSERT ignore duplicates
- Upsert (first to insert, then to update)
- INSERT from SELECT
- UPDATE with JOIN
- Multi-table UPDATE
- DELETE with JOIN
- Multi-table DELETE

sakila exercises
- test subqueries
- test CTEs

FOR UPDATE, FOR NO KEY UPDATE, FOR SHARE, FOR KEY SHARE 

sq README needs a FAQ section, just like how Maddy mail server does. I naturally gravitaed towards the FAQ link in order to learn more about maddy, and was able to learn so much it just from reading the FAQ alone.

IMPORTANT: before I do any kind of performance testing, I need to know:
- given a simple SQL query that instantiates a query, runs it and then exits, does the query get stack allocated?
    - I really need this to happen because it's the main reason why I went with queries as struct values instead of struct pointers
    - If I changed the queries to struct pointers instead, would the allocation/performance change?
- assuming a simple query is stack allocated, if I passed the entire query to LogQueryStats would it change to heap allocation?
    - I need to know this because it determines if I want to pass the Query interface to LogQueryStats for analytics purposes.
    - If LogQueryStats gets the Query interface, it can do interesting things like analyzing which tables and columns were most commonly used
    - But if performance takes a hit compared to just passing in the compiled query string and args, then maybe I'll leave it out
