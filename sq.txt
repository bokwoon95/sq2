sq.go
param.go
fmt.go
predicate.go
rowvalue.go
table_info.go
field_info.go <-> custom_field.go <-> assignment.go
blob_field.go | boolean_field.go | json_field.go | numberfield.go | string_field.go | time_field.go
join_table.go
variadic_query.go
subquery_field.go | cte.go
...
window.go (at very last because nothing depends on it)

Triggers system
- BeforeQuery
- AfterQuery
- InsteadOfQuery
how to get the column values? need to figure it out

InsertHandler
UpdateHandler
DeleteHandler
// oh no the predicate is not enough, what if it references a CTE too? Should we just include the whole CTE?
func HandleUpdate(ctx context.Context, rows *HandlerRows, query UpdateQuery) error
func HandleDelete(ctx context.Context, rows *HandlerRows, query DeleteQuery) error
func HandleInsert(ctx context.Context, rows *HandlerRows, query InsertQuery) error

var isset, isnull, issql bool
for i := 0; i < rows.Len(); i++ {
    var actor Actor
    isset, isnull, issql, actor.ActorID = rows.GetInt(i, ACTOR.ACTOR_ID)
    if isset && !isnull && !issql {
        if actor.ActorID < 0 {
            rows.SetInt(i, ACTOR.ACTOR_ID, -actor.ActorID)
            rows.Set(i, ACTOR.ACTOR_ID, nil)
        }
    }
    actor.FirstName, isset, isnull, issql = rows.GetString(i, ACTOR.FIRST_NAME)
    if isset && !isnull && !issql {
    }
    actor.LastName, isset, isnull, issql = rows.GetString(i, ACTOR.LAST_NAME)
    if isset && !isnull && !issql {
    }
    actor.LastUpdate, isset, isnull, issql = rows.GetTime(i, ACTOR.LAST_UPDATE)
    if isset && !isnull && !issql {
    }
}
rows.Exec()
if err != nil {
    return err
}

if you want people to be able to log who did what on a table using
logQueryStats, you need to provide the operation and tables affected as well.
At last for inserts and updates and deletes, the table name must be provided.
So that you can dispatch on that and insert the tenantID and the query run into
the corresponding audit table.

now the problem is: even after an insert there is no way of knowing which rows
were just inserted. Unlike the Update and Delete queries, there is no predicate
for Insert queries you can't just convert an Insert query into an equivalent
Select query like you can with an Update query.

I think scrap this idea. The best way is still to do your pre-query and
post-query processing using manually called functions, and you can write more
functions to automate that process (the onus is on you to call those functions
in the first place of course). That way you get full visibility of what data is
going in, what data was returned from INSERT/UPDATE/DELETE ... RETURNING.

sq README needs a FAQ section, just like how Maddy mail server does. I naturally gravitaed towards the FAQ link in order to learn more about maddy, and was able to learn so much it just from reading the FAQ alone.

IMPORTANT: before I do any kind of performance testing, I need to know:
- given a simple SQL query that instantiates a query, runs it and then exits, does the query get stack allocated?
    - I really need this to happen because it's the main reason why I went with queries as struct values instead of struct pointers
    - If I changed the queries to struct pointers instead, would the allocation/performance change?
- assuming a simple query is stack allocated, if I passed the entire query to LogQueryStats would it change to heap allocation?
    - I need to know this because it determines if I want to pass the Query interface to LogQueryStats for analytics purposes.
    - If LogQueryStats gets the Query interface, it can do interesting things like analyzing which tables and columns were most commonly used
    - But if performance takes a hit compared to just passing in the compiled query string and args, then maybe I'll leave it out
