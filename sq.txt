sq.go
param.go
fmt.go
predicate.go
rowvalue.go
table_info.go
field_info.go <-> custom_field.go <-> assignment.go
blob_field.go | boolean_field.go | json_field.go | numberfield.go | string_field.go | time_field.go
join_table.go
variadic_query.go
subquery_field.go | cte.go
...
window.go (at very last because nothing depends on it)

it is possible to remove sq's dependence on ddl for setting up the database
- check if the -resetdb flag was passed to the test. if it was, drop everything.
- check if the actor table exists. if it doesn't, run the init script.
- else check if the actor table has any rows. if it doesn't, run the data script.
- the tests that hit the db should never actually modify anything i.e. do DML in a transaction and rollback at the end of the test.
    - this way we can keep reusing the same db without needing to do data setup/teardown every time because its core data is unchanged

queries to test:
- SELECT
- SELECT DISTINCT
- SELECT DISTINCT ON
- SELECT EXISTS

FOR UPDATE, FOR NO KEY UPDATE, FOR SHARE, FOR KEY SHARE 

sq README needs a FAQ section, just like how Maddy mail server does. I naturally gravitaed towards the FAQ link in order to learn more about maddy, and was able to learn so much it just from reading the FAQ alone.

IMPORTANT: before I do any kind of performance testing, I need to know:
- given a simple SQL query that instantiates a query, runs it and then exits, does the query get stack allocated?
    - I really need this to happen because it's the main reason why I went with queries as struct values instead of struct pointers
    - If I changed the queries to struct pointers instead, would the allocation/performance change?
- assuming a simple query is stack allocated, if I passed the entire query to LogQueryStats would it change to heap allocation?
    - I need to know this because it determines if I want to pass the Query interface to LogQueryStats for analytics purposes.
    - If LogQueryStats gets the Query interface, it can do interesting things like analyzing which tables and columns were most commonly used
    - But if performance takes a hit compared to just passing in the compiled query string and args, then maybe I'll leave it out
