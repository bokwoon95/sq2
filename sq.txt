sq.go
param.go
fmt.go
predicate.go
rowvalue.go
generic_table.go
generic_field.go <-> custom_field.go <-> assignment.go
blob_field.go | boolean_field.go | json_field.go | numberfield.go | string_field.go | time_field.go

TODO: think about hiding the Format and Values fields in NumberField|StringField|TimeField because they get pretty annoying when autocompleting things. The IDE/LSP keeps thinking the Values slice as a valid argument to Fieldf/Predicatef/Sprintf etc.

BeforeQuery Hook
AfterQuery Hook
Before the query gets run by Fetch/Exec, you have the option to reach in and manipulate that query into one or more queries which are then run one after the other.
This is incredibly powerful for things like audit logging (INSERT into an audit table after any sensitive SELECT/INSERT/UPDATE/DELETE), as well as enforcing an application-wide constraints like for application-level temporal tables.
AfterQuery hook -could- be used to replace the logger hook
More importantly AfterQuery gives you the option to add post-query triggers: queries that are run only if the previous query succeeded. You can use it to validate DB state after running a particular query, and raising an error if so.
By running the AfterQuery Hook with a transaction, it gives you the ability to run one or more arbitrary queries on the database after the initial query and rollback the entire transaction if you wish.

The only downside is if you modify the SELECTed column list before it hits the database, then whatever comes back will most likely cause the rowmapper to panic.

sq README needs a FAQ section, just like how Maddy mail server does. I naturally gravitaed towards the FAQ link in order to learn more about maddy, and was able to learn so much it just from reading the FAQ alone.

row.Close() instead of row.Return() or row.Exit() with runtime.Goexit() shenanigans, because row.Close() can be orthogonal across Fetch, FetchOne and FetchSlice.
That is, instead of terminating the function there and then you simply mark the row iteration as complete and that subsequent row iterations should not occur.

How much slower is checking before quoting an identifier compared to just quoting it? Need to run some benchmarks, decide if it's worth it.
