sq.go
param.go
fmt.go
predicate.go
rowvalue.go
table_info.go
field_info.go <-> custom_field.go <-> assignment.go
blob_field.go | boolean_field.go | json_field.go | numberfield.go | string_field.go | time_field.go
subquery_field.go (subquery_test.go comes later, as it depends on other queries)
join_table.go

BeforeQuery Hook
AfterQuery Hook
Before the query gets run by Fetch/Exec, you have the option to reach in and manipulate that query into one or more queries which are then run one after the other.
This is incredibly powerful for things like audit logging (INSERT into an audit table after any sensitive SELECT/INSERT/UPDATE/DELETE), as well as enforcing an application-wide constraints like for application-level temporal tables.
AfterQuery hook -could- be used to replace the logger hook
More importantly AfterQuery gives you the option to add post-query triggers: queries that are run only if the previous query succeeded. You can use it to validate DB state after running a particular query, and raising an error if so.
By running the AfterQuery Hook with a transaction, it gives you the ability to run one or more arbitrary queries on the database after the initial query and rollback the entire transaction if you wish.

The only downside is if you modify the SELECTed column list before it hits the database, then whatever comes back will most likely cause the rowmapper to panic.

sq README needs a FAQ section, just like how Maddy mail server does. I naturally gravitaed towards the FAQ link in order to learn more about maddy, and was able to learn so much it just from reading the FAQ alone.

row.Close() instead of row.Return() or row.Exit() with runtime.Goexit() shenanigans, because row.Close() can be orthogonal across Fetch, FetchOne and FetchSlice.
That is, instead of terminating the function there and then you simply mark the row iteration as complete and that subsequent row iterations should not occur.

How much slower is checking before quoting an identifier compared to just quoting it? Need to run some benchmarks, decide if it's worth it.

investigate using type assertion and pointers fro performance:
https://www.reddit.com/r/golang/comments/9xs0r2/why_is_type_assertion_so_fast/
"interface asserted to pointer and pointer assigned to interface are both optimized by gc. For other kinds of types other than pointer, the larger size their values, the slower in assertions and assignments."
type assertions will be used very often during query manipulation (inside a trigger, etc). We want query manipulation to be fast.

investigate using type conversion and alias types for perforance:
https://stackoverflow.com/a/32253871
"converting to and from the underlying type of your custom type does not make a copy if it."
type conversions can be used very often for converting between the XXXField types and FieldInfo, which we want to be fast.

In general, will using struct values instead of struct pointers be faster when building a query? I need to know.
