ddl.go
lex.go
schema.go
table.go
t.go
catalog.go

Custom SQL-level filtering when retrieving the catalog is possible! Simply ask the user to provide an sq.Predicate which will get appended to the overall query. Fucking genius really.

NOTE: if the incoming table's schema is empty, set it to whatever the current default schema is. For postgres this can be found with SELECT current_schema, with mysql this can be found with SELECT database(). For sqlite the default schema is just an empty string.
    This step is important when it comes to diffing the catalogs, because the catalog loaded from the database will contain the schema name while the catalog loaded from the user-provided tables may omit the schema name.
    Maybe just treat the empty schema and the default schemas as the same when diffing the catalog, instead of literally filling in the schema name.

func NewCatalog() Catalog
func (catalog *Catalog) LoadDB(db sq.Queryer) error
func (catalog *Catalog) LoadTables(tables ...sq.SchemaTable) error
func (catalog *Catalog) LoadViews(views ...View) error
func (catalog *Catalog) LoadFunctions(functions ...Function) error
func DiffCatalog(gotCatalog, wantCatalog Catalog) (ChangeSet, error)
// DDL, Diff, DiffCommands, which to choose? DDL is bad because it takes up the `ddl` variable name, which is already used for the package.
func (set ChangeSet) Commands() Commands
func (cmds Commands) WriteOut(w io.Writer) error
func (cmds Commands) ExecDB(db sq.Queryer) error
func AutoMigrate(db sq.Queryer, tables sq.Tables, items ...interface{}) error
type AutoMigrateItems struct{
}
// have to decide between materializing all the params, accepting a AutoMigrateItems struct or simply ...interface{} my way out.
