package ddl3

import (
	"github.com/bokwoon95/sq"
)

const (
	postgresLastUpdateTrg = "CREATE TRIGGER {triggerName} BEFORE UPDATE ON {table}" +
		" FOR EACH ROW EXECUTE PROCEDURE last_updated_trg();"
	sqliteLastUpdateTrg = "CREATE TRIGGER {triggerName} AFTER UPDATE ON {table} BEGIN" +
		" UPDATE {table} SET {lastUpdate} = DATETIME('now') WHERE {field} = NEW.{field}" +
		" END;"
)

func NEW_ACTOR(dialect, alias string) ACTOR {
	var tbl ACTOR
	tbl.TableInfo = sq.TableInfo{TableName: "actor", TableAlias: alias}
	switch dialect {
	case sq.DialectPostgres:
		tbl.TableInfo.TableSchema = "public"
	case sq.DialectMySQL:
		tbl.TableInfo.TableSchema = "db"
	}
	tbl.ACTOR_ID = sq.NewNumberField("actor_id", tbl.TableInfo)
	tbl.FIRST_NAME = sq.NewStringField("first_name", tbl.TableInfo)
	tbl.LAST_NAME = sq.NewStringField("last_name", tbl.TableInfo)
	tbl.FULL_NAME = sq.NewStringField("full_name", tbl.TableInfo)
	tbl.FULL_NAME_REVERSED = sq.NewStringField("full_name_reversed", tbl.TableInfo)
	tbl.LAST_UPDATE = sq.NewTimeField("last_update", tbl.TableInfo)
	return tbl
}

type ACTOR struct {
	sq.TableInfo
	ACTOR_ID           sq.NumberField `ddl:"primarykey"`
	FIRST_NAME         sq.StringField `ddl:"notnull"`
	LAST_NAME          sq.StringField `ddl:"notnull index"`
	FULL_NAME          sq.StringField `ddl:"generated={first_name || ' ' || last_name} virtual"`
	FULL_NAME_REVERSED sq.StringField `ddl:"generated={last_name || ' ' || first_name} stored"`
	LAST_UPDATE        sq.TimeField   `ddl:"default=DATETIME('now') notnull"`
}

func (tbl ACTOR) DDL(dialect string, t *T) {
	switch dialect {
	case sq.DialectSQLite:
		t.Column(tbl.ACTOR_ID).Type("INTEGER").Autoincrement()
	case sq.DialectPostgres:
		t.Column(tbl.ACTOR_ID).Type("INT").Identity()
		t.Column(tbl.FULL_NAME).Generated("{} || ' ' || {}", tbl.FIRST_NAME, tbl.LAST_NAME).Stored()
		t.Column(tbl.LAST_UPDATE).Type("TIMESTAMPTZ").Default("NOW()")
		const triggerName = "actor_last_updated_before_update_trg"
		t.Trigger(triggerName).Sprintf(postgresLastUpdateTrg,
			sq.Param("triggerName", sq.Literal(triggerName)),
			sq.Param("table", tbl),
		)
	case sq.DialectMySQL:
		t.Column(tbl.ACTOR_ID).Type("INT").Autoincrement()
		t.Column(tbl.FIRST_NAME).Type("VARCHAR(45)")
		t.Column(tbl.LAST_NAME).Type("VARCHAR(45)")
		t.Column(tbl.FULL_NAME).Type("VARCHAR(45)").Generated("CONCAT({}, ' ', {})", tbl.FIRST_NAME, tbl.LAST_NAME)
		t.Column(tbl.FULL_NAME_REVERSED).Config(func(c *Column) {
			c.ColumnType = "VARCHAR(45)"
			c.GeneratedExpr = t.Sprintf("CONCAT({}, ' ', {})", tbl.LAST_NAME, tbl.FIRST_NAME)
			c.GeneratedExprStored = true
		})
		t.Column(tbl.LAST_UPDATE).Type("TIMESTAMP").Default("CURRENT_TIMESTAMP").OnUpdateCurrentTimestamp()
		const triggerName = "actor_last_updated_after_update_trg"
		t.Trigger(triggerName).Sprintf(sqliteLastUpdateTrg,
			sq.Param("triggerName", sq.Literal(triggerName)),
			sq.Param("table", tbl),
			sq.Param("lastUpdate", tbl.LAST_UPDATE),
			sq.Param("field", tbl.ACTOR_ID),
		)
	}
}

const ACTOR_SQLite = `CREATE TABLE actor (
    actor_id INTEGER PRIMARY KEY AUTOINCREMENT
    ,first_name TEXT NOT NULL
    ,last_name TEXT NOT NULL
    ,full_name TEXT GENERATED ALWAYS AS (first_name || ' ' || last_name) VIRTUAL
    ,full_name_reversed TEXT GENERATED ALWAYS AS (last_name || ' ' || first_name) STORED
    ,last_update DATETIME NOT NULL DEFAULT (DATETIME('now'))
);
CREATE INDEX actor_last_name_idx ON actor (last_name);`

const ACTOR_Postgres = `CREATE TABLE public.actor (
    actor_id INT GENERATED BY DEFAULT AS IDENTITY
    ,first_name TEXT NOT NULL
    ,last_name TEXT NOT NULL
    ,full_name TEXT GENERATED ALWAYS AS (first_name || ' ' || last_name) STORED
    ,full_name_reversed TEXT GENERATED ALWAYS AS (last_name || ' ' || first_name) STORED
    ,last_update TIMESTAMPTZ NOT NULL DEFAULT NOW()

    ,CONSTRAINT actor_actor_id_pkey PRIMARY KEY (actor_id)
);
CREATE INDEX actor_last_name_idx ON public.actor (last_name);`

const ACTOR_MySQL = `CREATE TABLE db.actor (
    actor_id INT AUTO_INCREMENT
    ,first_name VARCHAR(45) NOT NULL
    ,last_name VARCHAR(45) NOT NULL
    ,full_name VARCHAR(45) GENERATED ALWAYS AS (CONCAT(first_name, ' ', last_name)) VIRTUAL
    ,full_name_reversed VARCHAR(45) GENERATED ALWAYS AS (CONCAT(last_name, ' ', first_name)) STORED
    ,last_update TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP

    ,CONSTRAINT actor_actor_id_pkey PRIMARY KEY (actor_id)
);
CREATE INDEX actor_last_name_idx ON db.actor (last_name);`

func NEW_CATEGORY(dialect, alias string) CATEGORY {
	var tbl CATEGORY
	switch dialect {
	case sq.DialectPostgres:
		tbl.TableInfo.TableSchema = "public"
	case sq.DialectMySQL:
		tbl.TableInfo.TableSchema = "db"
	}
	_ = sq.ReflectTable(&tbl, alias)
	return tbl
}

type CATEGORY struct {
	sq.TableInfo
	CATEGORY_ID sq.NumberField `ddl:"type=INTEGER primarykey"`
	NAME        sq.StringField `ddl:"notnull"`
	LAST_UPDATE sq.TimeField   `ddl:"default=DATETIME('now') notnull"`
}

func (tbl CATEGORY) DDL(dialect string, t *T) {
	switch dialect {
	case sq.DialectPostgres:
		t.Column(tbl.CATEGORY_ID).Type("INT").Identity()
		t.Column(tbl.LAST_UPDATE).Type("TIMESTAMPTZ").Default("NOW()")
	case sq.DialectMySQL:
		t.Column(tbl.CATEGORY_ID).Type("INT").Autoincrement()
		t.Column(tbl.NAME).Type("VARCHAR(25)")
		t.Column(tbl.LAST_UPDATE).Type("TIMESTAMP").Default("CURRENT_TIMESTAMP").OnUpdateCurrentTimestamp()
	}
}

const CATEGORY_SQLite = `CREATE TABLE category (
    category_id INTEGER PRIMARY KEY
    ,name TEXT NOT NULL
    ,last_update DATETIME NOT NULL DEFAULT (DATETIME('now'))
);`

const CATEGORY_Postgres = `CREATE TABLE public.category (
    category_id INT GENERATED BY DEFAULT AS IDENTITY
    ,name TEXT NOT NULL
    ,last_update TIMESTAMPTZ NOT NULL DEFAULT NOW()

    ,CONSTRAINT category_category_id_pkey PRIMARY KEY (category_id)
);`

const CATEGORY_MySQL = `CREATE TABLE db.category (
    category_id INT AUTO_INCREMENT
    ,name VARCHAR(25) NOT NULL
    ,last_update TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP

    ,CONSTRAINT category_category_id_pkey PRIMARY KEY (category_id)
);`

func NEW_COUNTRY(dialect, alias string) COUNTRY {
	var tbl COUNTRY
	switch dialect {
	case sq.DialectPostgres:
		tbl.TableInfo.TableSchema = "public"
	case sq.DialectMySQL:
		tbl.TableInfo.TableSchema = "db"
	}
	_ = sq.ReflectTable(&tbl, alias)
	return tbl
}

type COUNTRY struct {
	sq.TableInfo
	COUNTRY_ID  sq.NumberField `ddl:"type=INTEGER primarykey"`
	COUNTRY     sq.StringField `ddl:"notnull"`
	LAST_UPDATE sq.TimeField   `ddl:"default=DATETIME('now') notnull"`
}

func (tbl COUNTRY) DDL(dialect string, t *T) {
	switch dialect {
	case sq.DialectPostgres:
		t.Column(tbl.COUNTRY_ID).Type("INT").Identity()
		t.Column(tbl.LAST_UPDATE).Type("TIMESTAMPTZ").Default("NOW()")
	case sq.DialectMySQL:
		t.Column(tbl.COUNTRY_ID).Type("INT").Autoincrement()
		t.Column(tbl.COUNTRY).Type("VARCHAR(50)")
		t.Column(tbl.LAST_UPDATE).Type("TIMESTAMP").Default("CURRENT_TIMESTAMP").OnUpdateCurrentTimestamp()
	}
}

const COUNTRY_SQLite = `CREATE TABLE country (
    country_id INTEGER PRIMARY KEY
    ,country TEXT NOT NULL
    ,last_update DATETIME NOT NULL DEFAULT (DATETIME('now'))
);`

const COUNTRY_Postgres = `CREATE TABLE public.country (
    country_id INT GENERATED BY DEFAULT AS IDENTITY
    ,country TEXT NOT NULL
    ,last_update TIMESTAMPTZ NOT NULL DEFAULT NOW()

    ,CONSTRAINT country_country_id_pkey PRIMARY KEY (country_id)
);`

const COUNTRY_MySQL = `CREATE TABLE db.country (
    country_id INT AUTO_INCREMENT
    ,country VARCHAR(50) NOT NULL
    ,last_update TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP

    ,CONSTRAINT country_country_id_pkey PRIMARY KEY (country_id)
);`

func NEW_CITY(dialect, alias string) CITY {
	var tbl CITY
	switch dialect {
	case sq.DialectPostgres:
		tbl.TableInfo.TableSchema = "public"
	case sq.DialectMySQL:
		tbl.TableInfo.TableSchema = "db"
	}
	_ = sq.ReflectTable(&tbl, alias)
	return tbl
}

type CITY struct {
	sq.TableInfo
	CITY_ID     sq.NumberField `ddl:"type=INTEGER primarykey"`
	CITY        sq.StringField `ddl:"notnull"`
	COUNTRY_ID  sq.NumberField `ddl:"notnull references={country onupdate=cascade ondelete=restrict} index"`
	LAST_UPDATE sq.TimeField   `ddl:"default=DATETIME('now') notnull"`
}

func (tbl CITY) DDL(dialect string, t *T) {
	COUNTRY := NEW_COUNTRY(dialect, "")
	switch dialect {
	case sq.DialectSQLite:
		t.ForeignKey(tbl.COUNTRY_ID).References(COUNTRY, COUNTRY.COUNTRY_ID).OnUpdate(CASCADE).OnDelete(RESTRICT)
	case sq.DialectPostgres:
		t.Column(tbl.CITY_ID).Type("INT").Identity()
		t.Column(tbl.LAST_UPDATE).Type("TIMESTAMPTZ").Default("NOW()")
	case sq.DialectMySQL:
		t.Column(tbl.CITY_ID).Type("INT").Autoincrement()
		t.Column(tbl.CITY).Type("VARCHAR(50)")
		t.Column(tbl.LAST_UPDATE).Type("TIMESTAMP").Default("CURRENT_TIMESTAMP").OnUpdateCurrentTimestamp()
		t.ForeignKey(tbl.COUNTRY_ID).References(COUNTRY, COUNTRY.COUNTRY_ID).OnUpdate(CASCADE).OnDelete(CASCADE)
	}
}

const CITY_SQLite = `CREATE TABLE city (
    city_id INTEGER PRIMARY KEY
    ,city TEXT NOT NULL
    ,country_id INT NOT NULL
    ,last_update DATETIME NOT NULL DEFAULT (DATETIME('now'))

    ,CONSTRAINT city_country_id_fkey FOREIGN KEY (country_id) REFERENCES country (country_id) ON UPDATE CASCADE ON DELETE RESTRICT
);
CREATE INDEX city_country_id_idx ON city (country_id);`

const CITY_Postgres = `CREATE TABLE public.city (
    city_id INT GENERATED BY DEFAULT AS IDENTITY
    ,city TEXT NOT NULL
    ,country_id INT NOT NULL
    ,last_update TIMESTAMPTZ NOT NULL DEFAULT NOW()

    ,CONSTRAINT city_city_id_pkey PRIMARY KEY (city_id)
);
ALTER TABLE public.city ADD CONSTRAINT city_country_id_fkey FOREIGN KEY (country_id) REFERENCES country ON UPDATE CASCADE ON DELETE RESTRICT;
CREATE INDEX city_country_id_idx ON public.city (country_id);`

const CITY_MySQL = `CREATE TABLE db.city (
    city_id INT AUTO_INCREMENT
    ,city VARCHAR(50) NOT NULL
    ,country_id INT NOT NULL
    ,last_update TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP

    ,CONSTRAINT city_city_id_pkey PRIMARY KEY (city_id)
);
ALTER TABLE db.city ADD CONSTRAINT city_country_id_fkey FOREIGN KEY (country_id) REFERENCES country (country_id) ON UPDATE CASCADE ON DELETE CASCADE;
CREATE INDEX city_country_id_idx ON db.city (country_id);`

func NEW_ADDRESS(dialect, alias string) ADDRESS {
	var tbl ADDRESS
	switch dialect {
	case sq.DialectPostgres:
		tbl.TableInfo.TableSchema = "public"
	case sq.DialectMySQL:
		tbl.TableInfo.TableSchema = "db"
	}
	_ = sq.ReflectTable(&tbl, alias)
	return tbl
}

type ADDRESS struct {
	sq.TableInfo
	ADDRESS_ID  sq.NumberField `ddl:"type=INTEGER primarykey"`
	ADDRESS     sq.StringField `ddl:"notnull"`
	ADDRESS2    sq.StringField
	DISTRICT    sq.StringField `ddl:"notnull"`
	CITY_ID     sq.NumberField `ddl:"notnull references={city.city_id onupdate=cascade ondelete=restrict} index"`
	POSTAL_CODE sq.StringField
	PHONE       sq.StringField `ddl:"notnull"`
	LAST_UPDATE sq.TimeField   `ddl:"default=DATETIME('now') notnull"`
}

func (tbl ADDRESS) DDL(dialect string, t *T) {
	CITY := NEW_CITY(dialect, "")
	switch dialect {
	case sq.DialectPostgres:
		t.Column(tbl.ADDRESS_ID).Type("INT").Identity()
		t.Column(tbl.LAST_UPDATE).Type("TIMESTAMPTZ").Default("NOW()")
	case sq.DialectMySQL:
		t.Column(tbl.ADDRESS_ID).Type("INT").Autoincrement()
		t.Column(tbl.ADDRESS).Type("VARCHAR(50)")
		t.Column(tbl.ADDRESS2).Type("VARCHAR(50)")
		t.Column(tbl.DISTRICT).Type("VARCHAR(20)")
		t.ForeignKey(tbl.CITY_ID).References(CITY, CITY.CITY_ID).OnUpdate(CASCADE).OnDelete(CASCADE)
		t.Column(tbl.POSTAL_CODE).Type("VARCHAR(10)")
		t.Column(tbl.PHONE).Type("VARCHAR(20)")
		t.Column(tbl.LAST_UPDATE).Type("TIMESTAMP").Default("CURRENT_TIMESTAMP").OnUpdateCurrentTimestamp()
	}
}

const ADDRESS_SQLite = `CREATE TABLE address (
    address_id INTEGER PRIMARY KEY
    ,address TEXT NOT NULL
    ,address2 TEXT
    ,district TEXT NOT NULL
    ,city_id INT NOT NULL
    ,postal_code TEXT
    ,phone TEXT NOT NULL
    ,last_update DATETIME NOT NULL DEFAULT (DATETIME('now'))

    ,CONSTRAINT address_city_id_fkey FOREIGN KEY (city_id) REFERENCES city (city_id) ON UPDATE CASCADE ON DELETE RESTRICT
);
CREATE INDEX address_city_id_idx ON address (city_id);`

const ADDRESS_Postgres = `CREATE TABLE public.address (
    address_id INT GENERATED BY DEFAULT AS IDENTITY
    ,address TEXT NOT NULL
    ,address2 TEXT
    ,district TEXT NOT NULL
    ,city_id INT NOT NULL
    ,postal_code TEXT
    ,phone TEXT NOT NULL
    ,last_update TIMESTAMPTZ NOT NULL DEFAULT NOW()

    ,CONSTRAINT address_address_id_pkey PRIMARY KEY (address_id)
);
ALTER TABLE public.address ADD CONSTRAINT address_city_id_fkey FOREIGN KEY (city_id) REFERENCES city (city_id) ON UPDATE CASCADE ON DELETE RESTRICT;
CREATE INDEX address_city_id_idx ON public.address (city_id);`

const ADDRESS_MySQL = `CREATE TABLE db.address (
    address_id INT AUTO_INCREMENT
    ,address VARCHAR(50) NOT NULL
    ,address2 VARCHAR(50)
    ,district VARCHAR(20) NOT NULL
    ,city_id INT NOT NULL
    ,postal_code VARCHAR(10)
    ,phone VARCHAR(20) NOT NULL
    ,last_update TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP

    ,CONSTRAINT address_address_id_pkey PRIMARY KEY (address_id)
);
ALTER TABLE db.address ADD CONSTRAINT address_city_id_fkey FOREIGN KEY (city_id) REFERENCES city (city_id) ON UPDATE CASCADE ON DELETE CASCADE;
CREATE INDEX address_city_id_idx ON db.address (city_id);`

func NEW_LANGUAGE(dialect, alias string) LANGUAGE {
	var tbl LANGUAGE
	switch dialect {
	case sq.DialectPostgres:
		tbl.TableInfo.TableSchema = "public"
	case sq.DialectMySQL:
		tbl.TableInfo.TableSchema = "db"
	}
	_ = sq.ReflectTable(&tbl, alias)
	return tbl
}

type LANGUAGE struct {
	sq.TableInfo
	LANGUAGE_ID sq.NumberField `ddl:"type=INTEGER primarykey"`
	NAME        sq.StringField `ddl:"notnull"`
	LAST_UPDATE sq.TimeField   `ddl:"default=DATETIME('now') notnull"`
}

func (tbl LANGUAGE) DDL(dialect string, t *T) {
	switch dialect {
	case sq.DialectPostgres:
		t.Column(tbl.LANGUAGE_ID).Type("INT").Identity()
		t.Column(tbl.LAST_UPDATE).Type("TIMESTAMPTZ").Default("NOW()")
	case sq.DialectMySQL:
		t.Column(tbl.LANGUAGE_ID).Type("INT").Autoincrement()
		t.Column(tbl.NAME).Type("CHAR(20)")
		t.Column(tbl.LAST_UPDATE).Type("TIMESTAMP").Default("CURRENT_TIMESTAMP").OnUpdateCurrentTimestamp()
	}
}

const LANGUAGE_SQLite = `CREATE TABLE language (
    language_id INTEGER PRIMARY KEY
    ,name TEXT NOT NULL
    ,last_update DATETIME NOT NULL DEFAULT (DATETIME('now'))
);`

const LANGUAGE_Postgres = `CREATE TABLE public.language (
    language_id INT GENERATED BY DEFAULT AS IDENTITY
    ,name TEXT NOT NULL
    ,last_update TIMESTAMPTZ NOT NULL DEFAULT NOW()

    ,CONSTRAINT language_language_id_pkey PRIMARY KEY (language_id)
);`

const LANGUAGE_MySQL = `CREATE TABLE db.language (
    language_id INT AUTO_INCREMENT
    ,name CHAR(20) NOT NULL
    ,last_update TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP

    ,CONSTRAINT language_language_id_pkey PRIMARY KEY (language_id)
);`

func NEW_FILM(dialect, alias string) FILM {
	var tbl FILM
	switch dialect {
	case sq.DialectPostgres:
		tbl.TableInfo.TableSchema = "public"
	case sq.DialectMySQL:
		tbl.TableInfo.TableSchema = "db"
	}
	_ = sq.ReflectTable(&tbl, alias)
	return tbl
}

type FILM struct {
	sq.TableInfo
	FILM_ID              sq.NumberField `ddl:"type=INTEGER primarykey"`
	TITLE                sq.StringField `ddl:"notnull index"`
	DESCRIPTION          sq.StringField
	RELEASE_YEAR         sq.NumberField
	LANGUAGE_ID          sq.NumberField `ddl:"notnull references={language.language_id onupdate=cascade ondelete=restrict} index"`
	ORIGINAL_LANGUAGE_ID sq.NumberField `ddl:"references={language.language_id onupdate=cascade ondelete=restrict} index"`
	RENTAL_DURATION      sq.NumberField `ddl:"default=3 notnull"`
	RENTAL_RATE          sq.NumberField `ddl:"type=DECIMAL(4,2) default=4.99 notnull"`
	LENGTH               sq.NumberField
	REPLACEMENT_COST     sq.NumberField `ddl:"type=DECIMAL(5,2) default=19.99 notnull"`
	RATING               sq.StringField `ddl:"default='G'"`
	SPECIAL_FEATURES     sq.CustomField `ddl:"type=JSON"`
	LAST_UPDATE          sq.TimeField   `ddl:"default=DATETIME('now') notnull"`
	FULLTEXT             sq.StringField
}

func (tbl FILM) DDL(dialect string, t *T) {
	switch dialect {
	case sq.DialectSQLite:
		t.Column(tbl.FULLTEXT).Ignore()
		t.Check("film_release_year_check", "{1} >= 1901 AND {1} <= 2155", tbl.RELEASE_YEAR)
		t.Check("film_rating_check", "{} IN ('G','PG','PG-13','R','NC-17')", tbl.RATING)
	case sq.DialectPostgres:
		t.Column(tbl.FILM_ID).Type("INT").Identity()
		t.Column(tbl.RELEASE_YEAR).Type("year")
		t.Column(tbl.RATING).Type("mpaa_rating").Default("'G'::mpaa_rating")
		t.Column(tbl.LAST_UPDATE).Type("TIMESTAMPTZ").Default("NOW()")
		t.Column(tbl.SPECIAL_FEATURES).Type("TEXT[]")
		t.Column(tbl.FULLTEXT).Type("TSVECTOR")
		t.Index(tbl.FULLTEXT).Using("GIST")
	case sq.DialectMySQL:
		t.Column(tbl.FILM_ID).Type("INT").Autoincrement()
		t.Column(tbl.TITLE).Type("VARCHAR(255)")
		t.Column(tbl.DESCRIPTION).Type("TEXT")
		t.Column(tbl.RATING).Type("ENUM('G','PG','PG-13','R','NC-17')")
		t.Column(tbl.LAST_UPDATE).Type("TIMESTAMP").Default("CURRENT_TIMESTAMP").OnUpdateCurrentTimestamp()
		t.Column(tbl.FULLTEXT).Ignore()
		t.Check("film_release_year_check", "{1} >= 1901 AND {1} <= 2155", tbl.RELEASE_YEAR)
	}
}

const FILM_SQLite = `CREATE TABLE film (
    film_id INTEGER PRIMARY KEY
    ,title TEXT NOT NULL
    ,description TEXT
    ,release_year INT
    ,language_id INT NOT NULL
    ,original_language_id INT
    ,rental_duration INT NOT NULL DEFAULT 3
    ,rental_rate DECIMAL(4,2) NOT NULL DEFAULT 4.99
    ,length INT
    ,replacement_cost DECIMAL(5,2) NOT NULL DEFAULT 19.99
    ,rating TEXT DEFAULT 'G'
    ,special_features JSON
    ,last_update DATETIME NOT NULL DEFAULT (DATETIME('now'))

    ,CONSTRAINT film_language_id_fkey FOREIGN KEY (language_id) REFERENCES language (language_id) ON UPDATE CASCADE ON DELETE RESTRICT
    ,CONSTRAINT film_original_language_id_fkey FOREIGN KEY (original_language_id) REFERENCES language (language_id) ON UPDATE CASCADE ON DELETE RESTRICT
    ,CONSTRAINT film_release_year_check CHECK (release_year >= 1901 AND release_year <= 2155)
    ,CONSTRAINT film_rating_check CHECK (rating IN ('G','PG','PG-13','R','NC-17'))
);
CREATE INDEX film_title_idx ON film (title);
CREATE INDEX film_language_id_idx ON film (language_id);
CREATE INDEX film_original_language_id_idx ON film (original_language_id);`

const FILM_Postgres = `CREATE TABLE public.film (
    film_id INT GENERATED BY DEFAULT AS IDENTITY
    ,title TEXT NOT NULL
    ,description TEXT
    ,release_year year
    ,language_id INT NOT NULL
    ,original_language_id INT
    ,rental_duration INT NOT NULL DEFAULT 3
    ,rental_rate DECIMAL(4,2) NOT NULL DEFAULT 4.99
    ,length INT
    ,replacement_cost DECIMAL(5,2) NOT NULL DEFAULT 19.99
    ,rating mpaa_rating DEFAULT 'G'::mpaa_rating
    ,special_features TEXT[]
    ,last_update TIMESTAMPTZ NOT NULL DEFAULT NOW()
    ,fulltext TSVECTOR

    ,CONSTRAINT film_film_id_pkey PRIMARY KEY (film_id)
);
ALTER TABLE public.film ADD CONSTRAINT film_language_id_fkey FOREIGN KEY (language_id) REFERENCES language (language_id) ON UPDATE CASCADE ON DELETE RESTRICT;
ALTER TABLE public.film ADD CONSTRAINT film_original_language_id_fkey FOREIGN KEY (original_language_id) REFERENCES language (language_id) ON UPDATE CASCADE ON DELETE RESTRICT;
CREATE INDEX film_title_idx ON public.film (title);
CREATE INDEX film_language_id_idx ON public.film (language_id);
CREATE INDEX film_original_language_id_idx ON public.film (original_language_id);
CREATE INDEX film_fulltext_idx ON public.film USING GIST (fulltext);`

const FILM_MySQL = `CREATE TABLE db.film (
    film_id INT AUTO_INCREMENT
    ,title VARCHAR(255) NOT NULL
    ,description TEXT
    ,release_year INT
    ,language_id INT NOT NULL
    ,original_language_id INT
    ,rental_duration INT NOT NULL DEFAULT 3
    ,rental_rate DECIMAL(4,2) NOT NULL DEFAULT 4.99
    ,length INT
    ,replacement_cost DECIMAL(5,2) NOT NULL DEFAULT 19.99
    ,rating ENUM('G','PG','PG-13','R','NC-17') DEFAULT 'G'
    ,special_features JSON
    ,last_update TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP

    ,CONSTRAINT film_film_id_pkey PRIMARY KEY (film_id)
    ,CONSTRAINT film_release_year_check CHECK (release_year >= 1901 AND release_year <= 2155)
);
ALTER TABLE db.film ADD CONSTRAINT film_language_id_fkey FOREIGN KEY (language_id) REFERENCES language (language_id) ON UPDATE CASCADE ON DELETE RESTRICT;
ALTER TABLE db.film ADD CONSTRAINT film_original_language_id_fkey FOREIGN KEY (original_language_id) REFERENCES language (language_id) ON UPDATE CASCADE ON DELETE RESTRICT;
CREATE INDEX film_title_idx ON db.film (title);
CREATE INDEX film_language_id_idx ON db.film (language_id);
CREATE INDEX film_original_language_id_idx ON db.film (original_language_id);`

func NEW_FILM_TEXT(dialect, alias string) FILM_TEXT {
	var tbl FILM_TEXT
	switch dialect {
	case sq.DialectPostgres:
		tbl.TableInfo.TableSchema = "public"
	case sq.DialectMySQL:
		tbl.TableInfo.TableSchema = "db"
	}
	_ = sq.ReflectTable(&tbl, alias)
	return tbl
}

type FILM_TEXT struct {
	sq.TableInfo
	FILM_ID     sq.NumberField
	TITLE       sq.StringField
	DESCRIPTION sq.StringField
}

func (tbl FILM_TEXT) DDL(dialect string, t *T) {
	switch dialect {
	case sq.DialectSQLite:
		t.VirtualTable("fts5", `content='film'`, `content_rowid='film_id'`)
		t.Column(tbl.FILM_ID).Ignore()
	case sq.DialectPostgres:
		break // no-op, postgres does not need a separate film_text table for full text search
	case sq.DialectMySQL:
		t.Column(tbl.FILM_ID).Type("INT").NotNull().PrimaryKey()
		t.Column(tbl.TITLE).Type("VARCHAR(255)").NotNull()
		t.Column(tbl.DESCRIPTION).Type("TEXT")
		t.Index(tbl.TITLE, tbl.DESCRIPTION).Using("FULLTEXT")
	}
}

const FILM_TEXT_SQLite = `CREATE VIRTUAL TABLE film_text USING fts5 (
    title
    ,description
    ,content='film'
    ,content_rowid='film_id'
);`

const FILM_TEXT_Postgres = `postgres does not use film_text table for FTS because it has fulltext TSVECTOR column in film table`

const FILM_TEXT_MySQL = `CREATE TABLE db.film_text (
    film_id INT NOT NULL
    ,title VARCHAR(255) NOT NULL
    ,description TEXT

    ,CONSTRAINT film_text_film_id_pkey PRIMARY KEY (film_id)
);
CREATE FULLTEXT INDEX film_text_title_description_idx ON db.film_text (title, description);`

func NEW_FILM_ACTOR(dialect, alias string) FILM_ACTOR {
	var tbl FILM_ACTOR
	switch dialect {
	case sq.DialectPostgres:
		tbl.TableInfo.TableSchema = "public"
	case sq.DialectMySQL:
		tbl.TableInfo.TableSchema = "db"
	}
	_ = sq.ReflectTable(&tbl, alias)
	return tbl
}

type FILM_ACTOR struct {
	sq.TableInfo `ddl:"index={. cols=actor_id,film_id unique}"`
	ACTOR_ID     sq.NumberField `ddl:"notnull references={actor.actor_id onupdate=cascade ondelete=restrict}"`
	FILM_ID      sq.NumberField `ddl:"notnull references={film.film_id onupdate=cascade ondelete=restrict} index"`
	LAST_UPDATE  sq.TimeField   `ddl:"default=DATETIME('now') notnull"`
}

func (tbl FILM_ACTOR) DDL(dialect string, t *T) {
	t.Index(tbl.ACTOR_ID, tbl.FILM_ID).Unique()
	switch dialect {
	case sq.DialectPostgres:
		t.Column(tbl.LAST_UPDATE).Type("TIMESTAMPTZ").Default("NOW()")
	case sq.DialectMySQL:
		t.Column(tbl.LAST_UPDATE).Type("TIMESTAMP").Default("CURRENT_TIMESTAMP").OnUpdateCurrentTimestamp()
	}
}

const FILM_ACTOR_SQLite = `CREATE TABLE film_actor (
    actor_id INT NOT NULL
    ,film_id INT NOT NULL
    ,last_update DATETIME NOT NULL DEFAULT (DATETIME('now'))

    ,CONSTRAINT film_actor_actor_id_fkey FOREIGN KEY (actor_id) REFERENCES actor (actor_id) ON UPDATE CASCADE ON DELETE RESTRICT
    ,CONSTRAINT film_actor_film_id_fkey FOREIGN KEY (film_id) REFERENCES film (film_id) ON UPDATE CASCADE ON DELETE RESTRICT
);
CREATE UNIQUE INDEX film_actor_actor_id_film_id_idx ON film_actor (actor_id, film_id);
CREATE INDEX film_actor_film_id_idx ON film_actor (film_id);`

const FILM_ACTOR_Postgres = `CREATE TABLE public.film_actor (
    actor_id INT NOT NULL
    ,film_id INT NOT NULL
    ,last_update TIMESTAMPTZ NOT NULL DEFAULT NOW()
);
ALTER TABLE public.film_actor ADD CONSTRAINT film_actor_actor_id_fkey FOREIGN KEY (actor_id) REFERENCES actor (actor_id) ON UPDATE CASCADE ON DELETE RESTRICT;
ALTER TABLE public.film_actor ADD CONSTRAINT film_actor_film_id_fkey FOREIGN KEY (film_id) REFERENCES film (film_id) ON UPDATE CASCADE ON DELETE RESTRICT;
CREATE UNIQUE INDEX film_actor_actor_id_film_id_idx ON public.film_actor (actor_id, film_id);
CREATE INDEX film_actor_film_id_idx ON public.film_actor (film_id);`

const FILM_ACTOR_MySQL = `CREATE TABLE db.film_actor (
    actor_id INT NOT NULL
    ,film_id INT NOT NULL
    ,last_update TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);
ALTER TABLE db.film_actor ADD CONSTRAINT film_actor_actor_id_fkey FOREIGN KEY (actor_id) REFERENCES actor (actor_id) ON UPDATE CASCADE ON DELETE RESTRICT;
ALTER TABLE db.film_actor ADD CONSTRAINT film_actor_film_id_fkey FOREIGN KEY (film_id) REFERENCES film (film_id) ON UPDATE CASCADE ON DELETE RESTRICT;
CREATE UNIQUE INDEX film_actor_actor_id_film_id_idx ON db.film_actor (actor_id, film_id);
CREATE INDEX film_actor_film_id_idx ON db.film_actor (film_id);`

func NEW_FILM_CATEGORY(dialect, alias string) FILM_CATEGORY {
	var tbl FILM_CATEGORY
	switch dialect {
	case sq.DialectPostgres:
		tbl.TableInfo.TableSchema = "public"
	case sq.DialectMySQL:
		tbl.TableInfo.TableSchema = "db"
	}
	_ = sq.ReflectTable(&tbl, alias)
	return tbl
}

type FILM_CATEGORY struct {
	sq.TableInfo
	FILM_ID     sq.NumberField `ddl:"notnull references={film.film_id onupdate=cascade ondelete=restrict}"`
	CATEGORY_ID sq.NumberField `ddl:"notnull references={category.category_id onupdate=cascade ondelete=restrict}"`
	LAST_UPDATE sq.TimeField   `ddl:"default=DATETIME('now') notnull"`
}

func (tbl FILM_CATEGORY) DDL(dialect string, t *T) {
	switch dialect {
	case sq.DialectPostgres:
		t.Column(tbl.LAST_UPDATE).Type("TIMESTAMPTZ").Default("NOW()")
	case sq.DialectMySQL:
		t.Column(tbl.LAST_UPDATE).Type("TIMESTAMP").Default("CURRENT_TIMESTAMP").OnUpdateCurrentTimestamp()
	}
}

const FILM_CATEGORY_SQLite = `CREATE TABLE film_category (
    film_id INT NOT NULL
    ,category_id INT NOT NULL
    ,last_update DATETIME NOT NULL DEFAULT (DATETIME('now'))

    ,CONSTRAINT film_category_film_id_fkey FOREIGN KEY (film_id) REFERENCES film (film_id) ON UPDATE CASCADE ON DELETE RESTRICT
    ,CONSTRAINT film_category_category_id_fkey FOREIGN KEY (category_id) REFERENCES category (category_id) ON UPDATE CASCADE ON DELETE RESTRICT
);`

const FILM_CATEGORY_Postgres = `CREATE TABLE public.film_category (
    film_id INT NOT NULL
    ,category_id INT NOT NULL
    ,last_update TIMESTAMPTZ NOT NULL DEFAULT NOW()
);
ALTER TABLE public.film_category ADD CONSTRAINT film_category_film_id_fkey FOREIGN KEY (film_id) REFERENCES film (film_id) ON UPDATE CASCADE ON DELETE RESTRICT;
ALTER TABLE public.film_category ADD CONSTRAINT film_category_category_id_fkey FOREIGN KEY (category_id) REFERENCES category (category_id) ON UPDATE CASCADE ON DELETE RESTRICT;`

const FILM_CATEGORY_MySQL = `CREATE TABLE db.film_category (
    film_id INT NOT NULL
    ,category_id INT NOT NULL
    ,last_update TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);
ALTER TABLE db.film_category ADD CONSTRAINT film_category_film_id_fkey FOREIGN KEY (film_id) REFERENCES film (film_id) ON UPDATE CASCADE ON DELETE RESTRICT;
ALTER TABLE db.film_category ADD CONSTRAINT film_category_category_id_fkey FOREIGN KEY (category_id) REFERENCES category (category_id) ON UPDATE CASCADE ON DELETE RESTRICT;`

func NEW_STAFF(dialect, alias string) STAFF {
	var tbl STAFF
	switch dialect {
	case sq.DialectPostgres:
		tbl.TableInfo.TableSchema = "public"
	case sq.DialectMySQL:
		tbl.TableInfo.TableSchema = "db"
	}
	_ = sq.ReflectTable(&tbl, alias)
	return tbl
}

type STAFF struct {
	sq.TableInfo
	STAFF_ID    sq.NumberField `ddl:"type=INTEGER primarykey"`
	FIRST_NAME  sq.StringField `ddl:"notnull"`
	LAST_NAME   sq.StringField `ddl:"notnull"`
	ADDRESS_ID  sq.NumberField `ddl:"notnull references={address.address_id onupdate=cascade ondelete=restrict}"`
	EMAIL       sq.StringField
	STORE_ID    sq.NumberField  `ddl:"references=store.store_id"`
	ACTIVE      sq.BooleanField `ddl:"default=TRUE notnull"`
	USERNAME    sq.StringField  `ddl:"notnull"`
	PASSWORD    sq.StringField
	LAST_UPDATE sq.TimeField `ddl:"default=DATETIME('now') notnull"`
	PICTURE     sq.BlobField
}

func (tbl STAFF) DDL(dialect string, t *T) {
	switch dialect {
	case sq.DialectPostgres:
		t.Column(tbl.STAFF_ID).Type("INT").Identity()
		t.Column(tbl.LAST_UPDATE).Type("TIMESTAMPTZ").Default("NOW()")
		t.Column(tbl.PICTURE).Type("BYTEA")
	case sq.DialectMySQL:
		t.Column(tbl.STAFF_ID).Type("INT").Autoincrement()
		t.Column(tbl.FIRST_NAME).Type("VARCHAR(45)")
		t.Column(tbl.LAST_NAME).Type("VARCHAR(45)")
		t.Column(tbl.EMAIL).Type("VARCHAR(50)")
		t.Column(tbl.USERNAME).Type("VARCHAR(16)")
		t.Column(tbl.PASSWORD).Type("VARCHAR(40)")
		t.Column(tbl.LAST_UPDATE).Type("TIMESTAMP").Default("CURRENT_TIMESTAMP").OnUpdateCurrentTimestamp()
	}
}

const STAFF_SQLite = `CREATE TABLE staff (
    staff_id INTEGER PRIMARY KEY
    ,first_name TEXT NOT NULL
    ,last_name TEXT NOT NULL
    ,address_id INT NOT NULL
    ,email TEXT
    ,store_id INT
    ,active BOOLEAN NOT NULL DEFAULT TRUE
    ,username TEXT NOT NULL
    ,password TEXT
    ,last_update DATETIME NOT NULL DEFAULT (DATETIME('now'))
    ,picture BLOB

    ,CONSTRAINT staff_address_id_fkey FOREIGN KEY (address_id) REFERENCES address (address_id) ON UPDATE CASCADE ON DELETE RESTRICT
    ,CONSTRAINT staff_store_id_fkey FOREIGN KEY (store_id) REFERENCES store (store_id)
);`

const STAFF_Postgres = `CREATE TABLE public.staff (
    staff_id INT GENERATED BY DEFAULT AS IDENTITY
    ,first_name TEXT NOT NULL
    ,last_name TEXT NOT NULL
    ,address_id INT NOT NULL
    ,email TEXT
    ,store_id INT
    ,active BOOLEAN NOT NULL DEFAULT TRUE
    ,username TEXT NOT NULL
    ,password TEXT
    ,last_update TIMESTAMPTZ NOT NULL DEFAULT NOW()
    ,picture BYTEA

    ,CONSTRAINT staff_staff_id_pkey PRIMARY KEY (staff_id)
);
ALTER TABLE public.staff ADD CONSTRAINT staff_address_id_fkey FOREIGN KEY (address_id) REFERENCES address (address_id) ON UPDATE CASCADE ON DELETE RESTRICT;
ALTER TABLE public.staff ADD CONSTRAINT staff_store_id_fkey FOREIGN KEY (store_id) REFERENCES store (store_id);`

const STAFF_MySQL = `CREATE TABLE db.staff (
    staff_id INT AUTO_INCREMENT
    ,first_name VARCHAR(45) NOT NULL
    ,last_name VARCHAR(45) NOT NULL
    ,address_id INT NOT NULL
    ,email VARCHAR(50)
    ,store_id INT
    ,active BOOLEAN NOT NULL DEFAULT TRUE
    ,username VARCHAR(16) NOT NULL
    ,password VARCHAR(40)
    ,last_update TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
    ,picture BLOB

    ,CONSTRAINT staff_staff_id_pkey PRIMARY KEY (staff_id)
);
ALTER TABLE db.staff ADD CONSTRAINT staff_address_id_fkey FOREIGN KEY (address_id) REFERENCES address (address_id) ON UPDATE CASCADE ON DELETE RESTRICT;
ALTER TABLE db.staff ADD CONSTRAINT staff_store_id_fkey FOREIGN KEY (store_id) REFERENCES store (store_id);`

func NEW_STORE(dialect, alias string) STORE {
	var tbl STORE
	switch dialect {
	case sq.DialectPostgres:
		tbl.TableInfo.TableSchema = "public"
	case sq.DialectMySQL:
		tbl.TableInfo.TableSchema = "db"
	}
	_ = sq.ReflectTable(&tbl, alias)
	return tbl
}

type STORE struct {
	sq.TableInfo
	STORE_ID         sq.NumberField `ddl:"type=INTEGER primarykey"`
	MANAGER_STAFF_ID sq.NumberField `ddl:"notnull references={staff.staff_id onupdate=cascade ondelete=restrict} index={. unique}"`
	ADDRESS_ID       sq.NumberField `ddl:"notnull references={address.address_id onupdate=cascade ondelete=restrict}"`
	LAST_UPDATE      sq.TimeField   `ddl:"default=DATETIME('now') notnull"`
}

func (tbl STORE) DDL(dialect string, t *T) {
	switch dialect {
	case sq.DialectPostgres:
		t.Column(tbl.STORE_ID).Type("INT").Identity()
		t.Column(tbl.LAST_UPDATE).Type("TIMESTAMPTZ").Default("NOW()")
	case sq.DialectMySQL:
		t.Column(tbl.STORE_ID).Type("INT").Autoincrement()
		t.Column(tbl.LAST_UPDATE).Type("TIMESTAMP").Default("CURRENT_TIMESTAMP").OnUpdateCurrentTimestamp()
	}
}

const STORE_SQLite = `CREATE TABLE store (
    store_id INTEGER PRIMARY KEY
    ,manager_staff_id INT NOT NULL
    ,address_id INT NOT NULL
    ,last_update DATETIME NOT NULL DEFAULT (DATETIME('now'))

    ,CONSTRAINT store_manager_staff_id_fkey FOREIGN KEY (manager_staff_id) REFERENCES staff (staff_id) ON UPDATE CASCADE ON DELETE RESTRICT
    ,CONSTRAINT store_address_id_fkey FOREIGN KEY (address_id) REFERENCES address (address_id) ON UPDATE CASCADE ON DELETE RESTRICT
);
CREATE UNIQUE INDEX store_manager_staff_id_idx ON store (manager_staff_id);`

const STORE_Postgres = `CREATE TABLE public.store (
    store_id INT GENERATED BY DEFAULT AS IDENTITY
    ,manager_staff_id INT NOT NULL
    ,address_id INT NOT NULL
    ,last_update TIMESTAMPTZ NOT NULL DEFAULT NOW()

    ,CONSTRAINT store_store_id_pkey PRIMARY KEY (store_id)
);
ALTER TABLE public.store ADD CONSTRAINT store_manager_staff_id_fkey FOREIGN KEY (manager_staff_id) REFERENCES staff (staff_id) ON UPDATE CASCADE ON DELETE RESTRICT;
ALTER TABLE public.store ADD CONSTRAINT store_address_id_fkey FOREIGN KEY (address_id) REFERENCES address (address_id) ON UPDATE CASCADE ON DELETE RESTRICT;
CREATE UNIQUE INDEX store_manager_staff_id_idx ON public.store (manager_staff_id);`

const STORE_MySQL = `CREATE TABLE db.store (
    store_id INT AUTO_INCREMENT
    ,manager_staff_id INT NOT NULL
    ,address_id INT NOT NULL
    ,last_update TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP

    ,CONSTRAINT store_store_id_pkey PRIMARY KEY (store_id)
);
ALTER TABLE db.store ADD CONSTRAINT store_manager_staff_id_fkey FOREIGN KEY (manager_staff_id) REFERENCES staff (staff_id) ON UPDATE CASCADE ON DELETE RESTRICT;
ALTER TABLE db.store ADD CONSTRAINT store_address_id_fkey FOREIGN KEY (address_id) REFERENCES address (address_id) ON UPDATE CASCADE ON DELETE RESTRICT;
CREATE UNIQUE INDEX store_manager_staff_id_idx ON db.store (manager_staff_id);`

func NEW_CUSTOMER(dialect, alias string) CUSTOMER {
	var tbl CUSTOMER
	switch dialect {
	case sq.DialectPostgres:
		tbl.TableInfo.TableSchema = "public"
	case sq.DialectMySQL:
		tbl.TableInfo.TableSchema = "db"
	}
	_ = sq.ReflectTable(&tbl, alias)
	return tbl
}

type CUSTOMER struct {
	sq.TableInfo `sq:"name=customer" ddl:"unique={. cols=email,first_name,last_name}"`
	CUSTOMER_ID  sq.NumberField  `ddl:"type=INTEGER primarykey"`
	STORE_ID     sq.NumberField  `ddl:"notnull index"`
	FIRST_NAME   sq.StringField  `ddl:"notnull"`
	LAST_NAME    sq.StringField  `ddl:"notnull index"`
	EMAIL        sq.StringField  `ddl:"unique"`
	ADDRESS_ID   sq.NumberField  `ddl:"notnull references={address.address_id onupdate=cascade ondelete=restrict} index"`
	ACTIVE       sq.BooleanField `ddl:"default=TRUE notnull"`
	DATA         sq.JSONField
	CREATE_DATE  sq.TimeField `ddl:"default=DATETIME('now') notnull"`
	LAST_UPDATE  sq.TimeField `ddl:"default=DATETIME('now')"`
}

func (tbl CUSTOMER) DDL(dialect string, t *T) {
	switch dialect {
	case sq.DialectPostgres:
		t.Column(tbl.CUSTOMER_ID).Type("INT").Identity()
		t.Column(tbl.CREATE_DATE).Type("TIMESTAMPTZ").Default("NOW()")
		t.Column(tbl.LAST_UPDATE).Type("TIMESTAMPTZ").Default("NOW()")
	case sq.DialectMySQL:
		t.Column(tbl.CUSTOMER_ID).Type("INT").Autoincrement()
		t.Column(tbl.FIRST_NAME).Type("VARCHAR(45)")
		t.Column(tbl.LAST_NAME).Type("VARCHAR(45)")
		t.Column(tbl.EMAIL).Type("VARCHAR(50)")
		t.Column(tbl.CREATE_DATE).Type("TIMESTAMP").Default("CURRENT_TIMESTAMP")
		t.Column(tbl.LAST_UPDATE).Type("TIMESTAMP").Default("CURRENT_TIMESTAMP").OnUpdateCurrentTimestamp()
	}
}

const CUSTOMER_SQLite = `CREATE TABLE customer (
    customer_id INTEGER PRIMARY KEY
    ,store_id INT NOT NULL
    ,first_name TEXT NOT NULL
    ,last_name TEXT NOT NULL
    ,email TEXT
    ,address_id INT NOT NULL
    ,active BOOLEAN NOT NULL DEFAULT TRUE
    ,data JSON
    ,create_date DATETIME NOT NULL DEFAULT (DATETIME('now'))
    ,last_update DATETIME DEFAULT (DATETIME('now'))

    ,CONSTRAINT customer_email_first_name_last_name_key UNIQUE (email, first_name, last_name)
    ,CONSTRAINT customer_email_key UNIQUE (email)
    ,CONSTRAINT customer_address_id_fkey FOREIGN KEY (address_id) REFERENCES address (address_id) ON UPDATE CASCADE ON DELETE RESTRICT
);
CREATE INDEX customer_store_id_idx ON customer (store_id);
CREATE INDEX customer_last_name_idx ON customer (last_name);
CREATE INDEX customer_address_id_idx ON customer (address_id);`

const CUSTOMER_Postgres = `CREATE TABLE public.customer (
    customer_id INT GENERATED BY DEFAULT AS IDENTITY
    ,store_id INT NOT NULL
    ,first_name TEXT NOT NULL
    ,last_name TEXT NOT NULL
    ,email TEXT
    ,address_id INT NOT NULL
    ,active BOOLEAN NOT NULL DEFAULT TRUE
    ,data JSONB
    ,create_date TIMESTAMPTZ NOT NULL DEFAULT NOW()
    ,last_update TIMESTAMPTZ DEFAULT NOW()

    ,CONSTRAINT customer_email_first_name_last_name_key UNIQUE (email, first_name, last_name)
    ,CONSTRAINT customer_customer_id_pkey PRIMARY KEY (customer_id)
    ,CONSTRAINT customer_email_key UNIQUE (email)
);
ALTER TABLE public.customer ADD CONSTRAINT customer_address_id_fkey FOREIGN KEY (address_id) REFERENCES address (address_id) ON UPDATE CASCADE ON DELETE RESTRICT;
CREATE INDEX customer_store_id_idx ON public.customer (store_id);
CREATE INDEX customer_last_name_idx ON public.customer (last_name);
CREATE INDEX customer_address_id_idx ON public.customer (address_id);`

const CUSTOMER_MySQL = `CREATE TABLE db.customer (
    customer_id INT AUTO_INCREMENT
    ,store_id INT NOT NULL
    ,first_name VARCHAR(45) NOT NULL
    ,last_name VARCHAR(45) NOT NULL
    ,email VARCHAR(50)
    ,address_id INT NOT NULL
    ,active BOOLEAN NOT NULL DEFAULT TRUE
    ,data JSON
    ,create_date TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
    ,last_update TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP

    ,CONSTRAINT customer_email_first_name_last_name_key UNIQUE (email, first_name, last_name)
    ,CONSTRAINT customer_customer_id_pkey PRIMARY KEY (customer_id)
    ,CONSTRAINT customer_email_key UNIQUE (email)
);
ALTER TABLE db.customer ADD CONSTRAINT customer_address_id_fkey FOREIGN KEY (address_id) REFERENCES address (address_id) ON UPDATE CASCADE ON DELETE RESTRICT;
CREATE INDEX customer_store_id_idx ON db.customer (store_id);
CREATE INDEX customer_last_name_idx ON db.customer (last_name);
CREATE INDEX customer_address_id_idx ON db.customer (address_id);`

func NEW_INVENTORY(dialect, alias string) INVENTORY {
	var tbl INVENTORY
	switch dialect {
	case sq.DialectPostgres:
		tbl.TableInfo.TableSchema = "public"
	case sq.DialectMySQL:
		tbl.TableInfo.TableSchema = "db"
	}
	_ = sq.ReflectTable(&tbl, alias)
	return tbl
}

type INVENTORY struct {
	sq.TableInfo `sq:"name=inventory" ddl:"index={. cols=store_id,film_id}"`
	INVENTORY_ID sq.NumberField `ddl:"type=INTEGER primarykey"`
	FILM_ID      sq.NumberField `ddl:"notnull references={film.film_id onupdate=cascade ondelete=restrict}"`
	STORE_ID     sq.NumberField `ddl:"notnull references={store.store_id onupdate=cascade ondelete=restrict}"`
	LAST_UPDATE  sq.TimeField   `ddl:"default=DATETIME('now') notnull"`
}

func (tbl INVENTORY) DDL(dialect string, t *T) {
	switch dialect {
	case sq.DialectPostgres:
		t.Column(tbl.INVENTORY_ID).Type("INT").Identity()
		t.Column(tbl.LAST_UPDATE).Type("TIMESTAMPTZ").Default("NOW()")
	case sq.DialectMySQL:
		t.Column(tbl.INVENTORY_ID).Type("INT").Autoincrement()
		t.Column(tbl.LAST_UPDATE).Type("TIMESTAMP").Default("CURRENT_TIMESTAMP").OnUpdateCurrentTimestamp()
	}
}

const INVENTORY_SQLite = `CREATE TABLE inventory (
    inventory_id INTEGER PRIMARY KEY
    ,film_id INT NOT NULL
    ,store_id INT NOT NULL
    ,last_update DATETIME NOT NULL DEFAULT (DATETIME('now'))

    ,CONSTRAINT inventory_film_id_fkey FOREIGN KEY (film_id) REFERENCES film (film_id) ON UPDATE CASCADE ON DELETE RESTRICT
    ,CONSTRAINT inventory_store_id_fkey FOREIGN KEY (store_id) REFERENCES store (store_id) ON UPDATE CASCADE ON DELETE RESTRICT
);
CREATE INDEX inventory_store_id_film_id_idx ON inventory (store_id, film_id);`

const INVENTORY_Postgres = `CREATE TABLE public.inventory (
    inventory_id INT GENERATED BY DEFAULT AS IDENTITY
    ,film_id INT NOT NULL
    ,store_id INT NOT NULL
    ,last_update TIMESTAMPTZ NOT NULL DEFAULT NOW()

    ,CONSTRAINT inventory_inventory_id_pkey PRIMARY KEY (inventory_id)
);
ALTER TABLE public.inventory ADD CONSTRAINT inventory_film_id_fkey FOREIGN KEY (film_id) REFERENCES film (film_id) ON UPDATE CASCADE ON DELETE RESTRICT;
ALTER TABLE public.inventory ADD CONSTRAINT inventory_store_id_fkey FOREIGN KEY (store_id) REFERENCES store (store_id) ON UPDATE CASCADE ON DELETE RESTRICT;
CREATE INDEX inventory_store_id_film_id_idx ON public.inventory (store_id, film_id);`

const INVENTORY_MySQL = `CREATE TABLE db.inventory (
    inventory_id INT AUTO_INCREMENT
    ,film_id INT NOT NULL
    ,store_id INT NOT NULL
    ,last_update TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP

    ,CONSTRAINT inventory_inventory_id_pkey PRIMARY KEY (inventory_id)
);
ALTER TABLE db.inventory ADD CONSTRAINT inventory_film_id_fkey FOREIGN KEY (film_id) REFERENCES film (film_id) ON UPDATE CASCADE ON DELETE RESTRICT;
ALTER TABLE db.inventory ADD CONSTRAINT inventory_store_id_fkey FOREIGN KEY (store_id) REFERENCES store (store_id) ON UPDATE CASCADE ON DELETE RESTRICT;
CREATE INDEX inventory_store_id_film_id_idx ON db.inventory (store_id, film_id);`

func NEW_RENTAL(dialect, alias string) RENTAL {
	var tbl RENTAL
	switch dialect {
	case sq.DialectPostgres:
		tbl.TableInfo.TableSchema = "public"
	case sq.DialectMySQL:
		tbl.TableInfo.TableSchema = "db"
	}
	_ = sq.ReflectTable(&tbl, alias)
	return tbl
}

type RENTAL struct {
	sq.TableInfo `ddl:"index={. cols=rental_date,inventory_id,customer_id unique}"`
	RENTAL_ID    sq.NumberField `ddl:"type=INTEGER primarykey"`
	RENTAL_DATE  sq.TimeField   `ddl:"notnull"`
	INVENTORY_ID sq.NumberField `ddl:"notnull index references={inventory.inventory_id onupdate=cascade ondelete=restrict}"`
	CUSTOMER_ID  sq.NumberField `ddl:"notnull index references={customer.customer_id onupdate=cascade ondelete=restrict}"`
	RETURN_DATE  sq.TimeField
	STAFF_ID     sq.NumberField `ddl:"notnull index references={staff.staff_id onupdate=cascade ondelete=restrict}"`
	LAST_UPDATE  sq.TimeField   `ddl:"default=DATETIME('now') notnull"`
}

func (tbl RENTAL) DDL(dialect string, t *T) {
	switch dialect {
	case sq.DialectPostgres:
		t.Column(tbl.RENTAL_ID).Type("INT").Identity()
		t.Column(tbl.RETURN_DATE).Type("TIMESTAMPTZ")
		t.Column(tbl.LAST_UPDATE).Type("TIMESTAMPTZ").Default("NOW()")
	case sq.DialectMySQL:
		t.Column(tbl.RENTAL_ID).Type("INT").Autoincrement()
		t.Column(tbl.RETURN_DATE).Type("TIMESTAMP")
		t.Column(tbl.LAST_UPDATE).Type("TIMESTAMP").Default("CURRENT_TIMESTAMP").OnUpdateCurrentTimestamp()
	}
}

const RENTAL_SQLite = `CREATE TABLE rental (
    rental_id INTEGER PRIMARY KEY
    ,rental_date DATETIME NOT NULL
    ,inventory_id INT NOT NULL
    ,customer_id INT NOT NULL
    ,return_date DATETIME
    ,staff_id INT NOT NULL
    ,last_update DATETIME NOT NULL DEFAULT (DATETIME('now'))

    ,CONSTRAINT rental_inventory_id_fkey FOREIGN KEY (inventory_id) REFERENCES inventory (inventory_id) ON UPDATE CASCADE ON DELETE RESTRICT
    ,CONSTRAINT rental_customer_id_fkey FOREIGN KEY (customer_id) REFERENCES customer (customer_id) ON UPDATE CASCADE ON DELETE RESTRICT
    ,CONSTRAINT rental_staff_id_fkey FOREIGN KEY (staff_id) REFERENCES staff (staff_id) ON UPDATE CASCADE ON DELETE RESTRICT
);
CREATE UNIQUE INDEX rental_rental_date_inventory_id_customer_id_idx ON rental (rental_date, inventory_id, customer_id);
CREATE INDEX rental_inventory_id_idx ON rental (inventory_id);
CREATE INDEX rental_customer_id_idx ON rental (customer_id);
CREATE INDEX rental_staff_id_idx ON rental (staff_id);`

const RENTAL_Postgres = `CREATE TABLE public.rental (
    rental_id INT GENERATED BY DEFAULT AS IDENTITY
    ,rental_date TIMESTAMPTZ NOT NULL
    ,inventory_id INT NOT NULL
    ,customer_id INT NOT NULL
    ,return_date TIMESTAMPTZ
    ,staff_id INT NOT NULL
    ,last_update TIMESTAMPTZ NOT NULL DEFAULT NOW()

    ,CONSTRAINT rental_rental_id_pkey PRIMARY KEY (rental_id)
);
ALTER TABLE public.rental ADD CONSTRAINT rental_inventory_id_fkey FOREIGN KEY (inventory_id) REFERENCES inventory (inventory_id) ON UPDATE CASCADE ON DELETE RESTRICT;
ALTER TABLE public.rental ADD CONSTRAINT rental_customer_id_fkey FOREIGN KEY (customer_id) REFERENCES customer (customer_id) ON UPDATE CASCADE ON DELETE RESTRICT;
ALTER TABLE public.rental ADD CONSTRAINT rental_staff_id_fkey FOREIGN KEY (staff_id) REFERENCES staff (staff_id) ON UPDATE CASCADE ON DELETE RESTRICT;
CREATE UNIQUE INDEX rental_rental_date_inventory_id_customer_id_idx ON public.rental (rental_date, inventory_id, customer_id);
CREATE INDEX rental_inventory_id_idx ON public.rental (inventory_id);
CREATE INDEX rental_customer_id_idx ON public.rental (customer_id);
CREATE INDEX rental_staff_id_idx ON public.rental (staff_id);`

const RENTAL_MySQL = `CREATE TABLE db.rental (
    rental_id INT AUTO_INCREMENT
    ,rental_date DATETIME NOT NULL
    ,inventory_id INT NOT NULL
    ,customer_id INT NOT NULL
    ,return_date TIMESTAMP
    ,staff_id INT NOT NULL
    ,last_update TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP

    ,CONSTRAINT rental_rental_id_pkey PRIMARY KEY (rental_id)
);
ALTER TABLE db.rental ADD CONSTRAINT rental_inventory_id_fkey FOREIGN KEY (inventory_id) REFERENCES inventory (inventory_id) ON UPDATE CASCADE ON DELETE RESTRICT;
ALTER TABLE db.rental ADD CONSTRAINT rental_customer_id_fkey FOREIGN KEY (customer_id) REFERENCES customer (customer_id) ON UPDATE CASCADE ON DELETE RESTRICT;
ALTER TABLE db.rental ADD CONSTRAINT rental_staff_id_fkey FOREIGN KEY (staff_id) REFERENCES staff (staff_id) ON UPDATE CASCADE ON DELETE RESTRICT;
CREATE UNIQUE INDEX rental_rental_date_inventory_id_customer_id_idx ON db.rental (rental_date, inventory_id, customer_id);
CREATE INDEX rental_inventory_id_idx ON db.rental (inventory_id);
CREATE INDEX rental_customer_id_idx ON db.rental (customer_id);
CREATE INDEX rental_staff_id_idx ON db.rental (staff_id);`

func NEW_PAYMENT(dialect, alias string) PAYMENT {
	var tbl PAYMENT
	switch dialect {
	case sq.DialectPostgres:
		tbl.TableInfo.TableSchema = "public"
	case sq.DialectMySQL:
		tbl.TableInfo.TableSchema = "db"
	}
	_ = sq.ReflectTable(&tbl, alias)
	return tbl
}

type PAYMENT struct {
	sq.TableInfo
	PAYMENT_ID   sq.NumberField `ddl:"type=INTEGER primarykey"`
	CUSTOMER_ID  sq.NumberField `ddl:"notnull index references={customer.customer_id onupdate=cascade ondelete=restrict}"`
	STAFF_ID     sq.NumberField `ddl:"notnull index references={staff.staff_id onupdate=cascade ondelete=restrict}"`
	RENTAL_ID    sq.NumberField `ddl:"references={rental.rental_id onupdate=cascade ondelete=restrict}"`
	AMOUNT       sq.NumberField `ddl:"type=DECIMAL(5,2) notnull"`
	PAYMENT_DATE sq.TimeField   `ddl:"notnull"`
}

func (tbl PAYMENT) DDL(dialect string, t *T) {
	switch dialect {
	case sq.DialectPostgres:
		t.Column(tbl.PAYMENT_ID).Type("INT").Identity()
		t.Column(tbl.PAYMENT_DATE).Type("TIMESTAMPTZ")
	case sq.DialectMySQL:
		t.Column(tbl.PAYMENT_ID).Type("INT").Autoincrement()
		t.Column(tbl.PAYMENT_DATE).Type("TIMESTAMP")
	}
}

const PAYMENT_SQLite = `CREATE TABLE payment (
    payment_id INTEGER PRIMARY KEY
    ,customer_id INT NOT NULL
    ,staff_id INT NOT NULL
    ,rental_id INT
    ,amount DECIMAL(5,2) NOT NULL
    ,payment_date DATETIME NOT NULL

    ,CONSTRAINT payment_customer_id_fkey FOREIGN KEY (customer_id) REFERENCES customer (customer_id) ON UPDATE CASCADE ON DELETE RESTRICT
    ,CONSTRAINT payment_staff_id_fkey FOREIGN KEY (staff_id) REFERENCES staff (staff_id) ON UPDATE CASCADE ON DELETE RESTRICT
    ,CONSTRAINT payment_rental_id_fkey FOREIGN KEY (rental_id) REFERENCES rental (rental_id) ON UPDATE CASCADE ON DELETE RESTRICT
);
CREATE INDEX payment_customer_id_idx ON payment (customer_id);
CREATE INDEX payment_staff_id_idx ON payment (staff_id);`

const PAYMENT_Postgres = `CREATE TABLE public.payment (
    payment_id INT GENERATED BY DEFAULT AS IDENTITY
    ,customer_id INT NOT NULL
    ,staff_id INT NOT NULL
    ,rental_id INT
    ,amount DECIMAL(5,2) NOT NULL
    ,payment_date TIMESTAMPTZ NOT NULL

    ,CONSTRAINT payment_payment_id_pkey PRIMARY KEY (payment_id)
);
ALTER TABLE public.payment ADD CONSTRAINT payment_customer_id_fkey FOREIGN KEY (customer_id) REFERENCES customer (customer_id) ON UPDATE CASCADE ON DELETE RESTRICT;
ALTER TABLE public.payment ADD CONSTRAINT payment_staff_id_fkey FOREIGN KEY (staff_id) REFERENCES staff (staff_id) ON UPDATE CASCADE ON DELETE RESTRICT;
ALTER TABLE public.payment ADD CONSTRAINT payment_rental_id_fkey FOREIGN KEY (rental_id) REFERENCES rental (rental_id) ON UPDATE CASCADE ON DELETE RESTRICT;
CREATE INDEX payment_customer_id_idx ON public.payment (customer_id);
CREATE INDEX payment_staff_id_idx ON public.payment (staff_id);`

const PAYMENT_MySQL = `CREATE TABLE db.payment (
    payment_id INT AUTO_INCREMENT
    ,customer_id INT NOT NULL
    ,staff_id INT NOT NULL
    ,rental_id INT
    ,amount DECIMAL(5,2) NOT NULL
    ,payment_date TIMESTAMP NOT NULL

    ,CONSTRAINT payment_payment_id_pkey PRIMARY KEY (payment_id)
);
ALTER TABLE db.payment ADD CONSTRAINT payment_customer_id_fkey FOREIGN KEY (customer_id) REFERENCES customer (customer_id) ON UPDATE CASCADE ON DELETE RESTRICT;
ALTER TABLE db.payment ADD CONSTRAINT payment_staff_id_fkey FOREIGN KEY (staff_id) REFERENCES staff (staff_id) ON UPDATE CASCADE ON DELETE RESTRICT;
ALTER TABLE db.payment ADD CONSTRAINT payment_rental_id_fkey FOREIGN KEY (rental_id) REFERENCES rental (rental_id) ON UPDATE CASCADE ON DELETE RESTRICT;
CREATE INDEX payment_customer_id_idx ON db.payment (customer_id);
CREATE INDEX payment_staff_id_idx ON db.payment (staff_id);`

func NEW_DUMMY_TABLE(dialect, alias string) DUMMY_TABLE {
	var tbl DUMMY_TABLE
	switch dialect {
	case sq.DialectPostgres:
		tbl.TableInfo.TableSchema = "public"
	case sq.DialectMySQL:
		tbl.TableInfo.TableSchema = "db"
	}
	_ = sq.ReflectTable(&tbl, alias)
	return tbl
}

type DUMMY_TABLE struct {
	sq.TableInfo `ddl:"primarykey={. cols=id1,id2} unique={. cols=score,color}"`
	ID1          sq.NumberField
	ID2          sq.StringField
	SCORE        sq.NumberField
	COLOR        sq.StringField `ddl:"collate=nocase default='red'"`
	DATA         sq.JSONField
}

func (tbl DUMMY_TABLE) DDL(dialect string, t *T) {
	const indexName = "dummy_table_complex_expr_idx"
	switch dialect {
	case sq.DialectSQLite:
		t.Column(tbl.COLOR).Collate("nocase")
		t.NameIndex(indexName,
			tbl.SCORE,
			sq.Fieldf("SUBSTR({}, 1, 2)", tbl.COLOR),
			sq.Fieldf("{} || {}", tbl.COLOR, " abcd"),
			sq.Fieldf("CAST(JSON_EXTRACT({}, {}) AS INT)", tbl.DATA, "$.age"),
		).Where("{} = {}", tbl.COLOR, "red")
	case sq.DialectPostgres:
		t.Column(tbl.ID1).AlwaysIdentity()
		t.Column(tbl.COLOR).Collate("C")
		t.NameIndex(indexName,
			tbl.SCORE,
			sq.Fieldf("SUBSTR({}, 1, 2)", tbl.COLOR),
			sq.Fieldf("{} || {}", tbl.COLOR, " abcd"),
			sq.Fieldf("({}->>{})::INT", tbl.DATA, "age"),
		).Where("{} = {}", tbl.COLOR, "red")
		t.NameIndex("dummy_table_id2_idx", sq.Literal(`id2 COLLATE "C"`))
		t.NameIndex("dummy_table_color_idx", sq.Literal("color text_pattern_ops"))
	case sq.DialectMySQL:
		t.Column(tbl.COLOR).Type("VARCHAR(50)").Collate("latin1_swedish_ci")
		t.NameIndex(indexName,
			tbl.SCORE,
			sq.Fieldf("SUBSTR({}, 1, 2)", tbl.COLOR),
			sq.Fieldf("CONCAT({}, {})", tbl.COLOR, " abcd"),
			sq.Fieldf("CAST({}->>{} AS SIGNED)", tbl.DATA, "$.age"),
		)
	}
	t.Check("dummy_table_score_positive_check", "{} > 0", tbl.SCORE)
	t.Check("dummy_table_score_id1_greater_than_check", "{} > {}", tbl.SCORE, tbl.ID1)
	t.PrimaryKey(tbl.ID1, tbl.ID2)
	t.Unique(tbl.SCORE, tbl.COLOR)
}

const DUMMY_TABLE_SQLite = `CREATE TABLE dummy_table (
    id1 INT
    ,id2 TEXT
    ,score INT
    ,color TEXT DEFAULT 'red' COLLATE nocase
    ,data JSON

    ,CONSTRAINT dummy_table_id1_id2_pkey PRIMARY KEY (id1, id2)
    ,CONSTRAINT dummy_table_score_color_key UNIQUE (score, color)
    ,CONSTRAINT dummy_table_score_positive_check CHECK (score > 0)
    ,CONSTRAINT dummy_table_score_id1_greater_than_check CHECK (score > id1)
);
CREATE INDEX dummy_table_complex_expr_idx ON dummy_table (score, (SUBSTR(color, 1, 2)), (color || ' abcd'), (CAST(JSON_EXTRACT(data, '$.age') AS INT))) WHERE color = 'red';`

const DUMMY_TABLE_Postgres = `CREATE TABLE public.dummy_table (
    id1 INT GENERATED ALWAYS AS IDENTITY
    ,id2 TEXT
    ,score INT
    ,color TEXT DEFAULT 'red' COLLATE "C"
    ,data JSONB

    ,CONSTRAINT dummy_table_id1_id2_pkey PRIMARY KEY (id1, id2)
    ,CONSTRAINT dummy_table_score_color_key UNIQUE (score, color)
    ,CONSTRAINT dummy_table_score_positive_check CHECK (score > 0)
    ,CONSTRAINT dummy_table_score_id1_greater_than_check CHECK (score > id1)
);
CREATE INDEX dummy_table_complex_expr_idx ON public.dummy_table (score, (SUBSTR(color, 1, 2)), (color || ' abcd'), ((data->>'age')::INT)) WHERE color = 'red';
CREATE INDEX dummy_table_id2_idx ON public.dummy_table (id2 COLLATE "C");
CREATE INDEX dummy_table_color_idx ON public.dummy_table (color text_pattern_ops);`

const DUMMY_TABLE_MySQL = `CREATE TABLE db.dummy_table (
    id1 INT
    ,id2 VARCHAR(255)
    ,score INT
    ,color VARCHAR(50) DEFAULT 'red' COLLATE latin1_swedish_ci
    ,data JSON

    ,CONSTRAINT dummy_table_id1_id2_pkey PRIMARY KEY (id1, id2)
    ,CONSTRAINT dummy_table_score_color_key UNIQUE (score, color)
    ,CONSTRAINT dummy_table_score_positive_check CHECK (score > 0)
    ,CONSTRAINT dummy_table_score_id1_greater_than_check CHECK (score > id1)
);
CREATE INDEX dummy_table_complex_expr_idx ON db.dummy_table (score, (SUBSTR(color, 1, 2)), (CONCAT(color, ' abcd')), (CAST(data->>'$.age' AS SIGNED)));`

func NEW_DUMMY_TABLE_2(dialect, alias string) DUMMY_TABLE_2 {
	var tbl DUMMY_TABLE_2
	switch dialect {
	case sq.DialectPostgres:
		tbl.TableInfo.TableSchema = "public"
	case sq.DialectMySQL:
		tbl.TableInfo.TableSchema = "db"
	}
	_ = sq.ReflectTable(&tbl, alias)
	return tbl
}

type DUMMY_TABLE_2 struct {
	sq.TableInfo `ddl:"references={dummy_table.id1,id2 cols=id1,id2 onupdate=cascade ondelete=restrict}"`
	ID1          sq.NumberField
	ID2          sq.StringField
}

func (tbl DUMMY_TABLE_2) DDL(dialect string, t *T) {
	ref := NEW_DUMMY_TABLE(dialect, "")
	switch dialect {
	case sq.DialectPostgres, sq.DialectMySQL:
		t.ForeignKey(tbl.ID1, tbl.ID2).References(ref, ref.ID1, ref.ID2).OnUpdate("CASCADE").OnDelete("RESTRICT")
	}
}

const DUMMY_TABLE_2_SQLite = `CREATE TABLE dummy_table_2 (
    id1 INT
    ,id2 TEXT

    ,CONSTRAINT dummy_table_2_id1_id2_fkey FOREIGN KEY (id1, id2) REFERENCES dummy_table (id1, id2) ON UPDATE CASCADE ON DELETE RESTRICT
);`

const DUMMY_TABLE_2_Postgres = `CREATE TABLE public.dummy_table_2 (
    id1 INT
    ,id2 TEXT
);
ALTER TABLE public.dummy_table_2 ADD CONSTRAINT dummy_table_2_id1_id2_fkey FOREIGN KEY (id1, id2) REFERENCES dummy_table (id1, id2) ON UPDATE CASCADE ON DELETE RESTRICT;`

const DUMMY_TABLE_2_MySQL = `CREATE TABLE db.dummy_table_2 (
    id1 INT
    ,id2 VARCHAR(255)
);
ALTER TABLE db.dummy_table_2 ADD CONSTRAINT dummy_table_2_id1_id2_fkey FOREIGN KEY (id1, id2) REFERENCES dummy_table (id1, id2) ON UPDATE CASCADE ON DELETE RESTRICT;`

func json_object_agg(dialect string, name, value interface{}) sq.CustomField {
	if query, ok := value.(sq.Query); ok {
		value = sq.Fieldf("({})", query)
	}
	// TODO: if dialect not recognized, CustomField's StickyError should be set
	// instead. This will be -incredibly- useful for people who want to define
	// their own SQL functions but need some way to signal an error. But how do
	// I want to expose this API to the user?
	// NOTE: what if we just defined a default fallback here, and let the SQL
	// database point out the error? Then CustomField no longer needs a
	// StickyError.
	switch dialect {
	case sq.DialectSQLite:
		return sq.Fieldf("json_group_object({}, {})", name, value)
	case sq.DialectPostgres:
		return sq.Fieldf("jsonb_object_agg({}, {})", name, value)
	case sq.DialectMySQL:
		return sq.Fieldf("json_objectagg({}, {})", name, value)
	default:
		return sq.Fieldf("%!(unrecognized dialect=" + dialect + ")")
	}
}

func json_array_agg(dialect string, value interface{}) sq.CustomField {
	switch dialect {
	case sq.DialectSQLite:
		return sq.Fieldf("json_group_array({})", value)
	case sq.DialectPostgres:
		return sq.Fieldf("jsonb_agg({})", value)
	case sq.DialectMySQL:
		return sq.Fieldf("jsonb_arrayagg({})", value)
	default:
		return sq.Fieldf("%!(unrecognized dialect=" + dialect + ")")
	}
}

type ACTOR_INFO struct {
	sq.TableInfo
	ACTOR_ID   sq.NumberField
	FIRST_NAME sq.StringField
	LAST_NAME  sq.StringField
	FILM_INFO  sq.JSONField
}

func (_ ACTOR_INFO) View(dialect string) (sq.Query, error) {
	ACTOR := NEW_ACTOR(dialect, "a")
	FILM := NEW_FILM(dialect, "f")
	FILM_ACTOR := NEW_FILM_ACTOR(dialect, "fa")
	FILM_CATEGORY := NEW_FILM_CATEGORY(dialect, "fc")
	CATEGORY := NEW_CATEGORY(dialect, "c")
	var q sq.SelectQuery
	q.FromTable = ACTOR
	q.JoinTables = sq.JoinTables{
		sq.LeftJoin(FILM_ACTOR, FILM_ACTOR.ACTOR_ID.Eq(ACTOR.ACTOR_ID)),
		sq.LeftJoin(FILM_CATEGORY, FILM_CATEGORY.FILM_ID.Eq(FILM_ACTOR.FILM_ID)),
		sq.LeftJoin(CATEGORY, CATEGORY.CATEGORY_ID.Eq(FILM_CATEGORY.CATEGORY_ID)),
	}
	q.GroupByFields = sq.Fields{ACTOR.ACTOR_ID, ACTOR.FIRST_NAME, ACTOR.LAST_NAME}
	q.SelectFields = sq.AliasFields{
		ACTOR.ACTOR_ID,
		ACTOR.FIRST_NAME,
		ACTOR.LAST_NAME,
		json_object_agg(dialect, CATEGORY.NAME, sq.SQLite.
			Select(json_array_agg(dialect, FILM.TITLE)).
			From(FILM).
			Join(FILM_CATEGORY, FILM_CATEGORY.FILM_ID.Eq(FILM.FILM_ID)).
			Join(FILM_ACTOR, FILM_ACTOR.FILM_ID.Eq(FILM.FILM_ID)).
			Where(
				FILM_CATEGORY.CATEGORY_ID.Eq(CATEGORY.CATEGORY_ID),
				FILM_ACTOR.ACTOR_ID.Eq(ACTOR.ACTOR_ID),
			).
			GroupBy(FILM_ACTOR.ACTOR_ID),
		).As("film_info"),
	}
	return q, nil
}

type CUSTOMER_LIST struct {
	sq.TableInfo
	ID       sq.NumberField
	NAME     sq.StringField
	ADDRESS  sq.StringField
	ZIP_CODE sq.StringField
	PHONE    sq.StringField
	CITY     sq.StringField
	COUNTRY  sq.StringField
	NOTES    sq.StringField
	SID      sq.NumberField
}

func (_ CUSTOMER_LIST) View(dialect string) (sq.Query, error) {
	CUSTOMER := NEW_CUSTOMER(dialect, "cu")
	ADDRESS := NEW_ADDRESS(dialect, "a")
	CITY := NEW_CITY(dialect, "")
	COUNTRY := NEW_COUNTRY(dialect, "")
	var q sq.SelectQuery
	q.FromTable = CUSTOMER
	q.JoinTables = sq.JoinTables{
		sq.Join(ADDRESS, ADDRESS.ADDRESS_ID.Eq(CUSTOMER.ADDRESS_ID)),
		sq.Join(CITY, CITY.CITY_ID.Eq(ADDRESS.CITY_ID)),
		sq.Join(COUNTRY, COUNTRY.COUNTRY_ID.Eq(CITY.COUNTRY_ID)),
	}
	nameExpr := "{} || ' ' || {}"
	if dialect == sq.DialectMySQL {
		nameExpr = "CONCAT({}, ' ', {})"
	}
	q.SelectFields = sq.AliasFields{
		CUSTOMER.CUSTOMER_ID.As("id"),
		sq.Fieldf(nameExpr, CUSTOMER.FIRST_NAME, CUSTOMER.LAST_NAME).As("name"),
		ADDRESS.ADDRESS,
		ADDRESS.POSTAL_CODE.As("zip_code"),
		ADDRESS.PHONE,
		CITY.CITY,
		COUNTRY.COUNTRY,
		sq.CaseWhen(CUSTOMER.ACTIVE, "active").Else(""),
		CUSTOMER.STORE_ID.As("sid"),
	}
	return q, nil
}

type FILM_LIST struct {
	sq.TableInfo
	FID         sq.NumberField
	TITLE       sq.StringField
	DESCRIPTION sq.StringField
	CATEGORY    sq.StringField
	PRICE       sq.NumberField
	LENGTH      sq.NumberField
	RATING      sq.StringField
	ACTORS      sq.JSONField
}

func (_ FILM_LIST) View(dialect string) (sq.Query, error) {
	CATEGORY := NEW_CATEGORY(dialect, "")
	FILM_CATEGORY := NEW_FILM_CATEGORY(dialect, "")
	FILM := NEW_FILM(dialect, "")
	FILM_ACTOR := NEW_FILM_ACTOR(dialect, "")
	ACTOR := NEW_ACTOR(dialect, "")
	var q sq.SelectQuery
	q.FromTable = CATEGORY
	q.JoinTables = sq.JoinTables{
		sq.LeftJoin(FILM_CATEGORY, FILM_CATEGORY.CATEGORY_ID.Eq(CATEGORY.CATEGORY_ID)),
		sq.LeftJoin(FILM, FILM.FILM_ID.Eq(FILM_CATEGORY.FILM_ID)),
		sq.Join(FILM_ACTOR, FILM_ACTOR.FILM_ID.Eq(FILM.FILM_ID)),
		sq.Join(ACTOR, ACTOR.ACTOR_ID.Eq(FILM_ACTOR.ACTOR_ID)),
	}
	q.GroupByFields = sq.Fields{
		FILM.FILM_ID,
		FILM.TITLE,
		FILM.DESCRIPTION,
		CATEGORY.NAME,
		FILM.RENTAL_RATE,
		FILM.LENGTH,
		FILM.RATING,
	}
	nameExpr := "{} || ' ' || {}"
	if dialect == sq.DialectMySQL {
		nameExpr = "CONCAT({}, ' ', {})"
	}
	q.SelectFields = sq.AliasFields{
		FILM.FILM_ID.As("fid"),
		FILM.TITLE,
		FILM.DESCRIPTION,
		CATEGORY.NAME.As("category"),
		FILM.RENTAL_RATE.As("price"),
		FILM.LENGTH,
		FILM.RATING,
		json_array_agg(dialect, sq.Fieldf(nameExpr, ACTOR.FIRST_NAME, ACTOR.LAST_NAME)),
	}
	return q, nil
}

type NICER_BUT_SLOWER_FILM_LIST struct {
	sq.TableInfo
	FID         sq.NumberField
	TITLE       sq.StringField
	DESCRIPTION sq.StringField
	CATEGORY    sq.StringField
	PRICE       sq.NumberField
	LENGTH      sq.NumberField
	RATING      sq.StringField
	ACTORS      sq.JSONField
}

func (_ NICER_BUT_SLOWER_FILM_LIST) View(dialect string) (sq.Query, error) {
	CATEGORY := NEW_CATEGORY(dialect, "")
	FILM_CATEGORY := NEW_FILM_CATEGORY(dialect, "")
	FILM := NEW_FILM(dialect, "")
	FILM_ACTOR := NEW_FILM_ACTOR(dialect, "")
	ACTOR := NEW_ACTOR(dialect, "")
	var q sq.SelectQuery
	q.FromTable = CATEGORY
	q.JoinTables = sq.JoinTables{
		sq.LeftJoin(FILM_CATEGORY, FILM_CATEGORY.CATEGORY_ID.Eq(CATEGORY.CATEGORY_ID)),
		sq.LeftJoin(FILM, FILM.FILM_ID.Eq(FILM_CATEGORY.FILM_ID)),
		sq.Join(FILM_ACTOR, FILM_ACTOR.FILM_ID.Eq(FILM.FILM_ID)),
		sq.Join(ACTOR, ACTOR.ACTOR_ID.Eq(FILM_ACTOR.ACTOR_ID)),
	}
	q.GroupByFields = sq.Fields{
		FILM.FILM_ID,
		FILM.TITLE,
		FILM.DESCRIPTION,
		CATEGORY.NAME,
		FILM.RENTAL_RATE,
		FILM.LENGTH,
		FILM.RATING,
	}
	nameExpr := "UPPER(SUBSTRING({1}, 1, 1))" +
		" || LOWER(SUBSTRING({1}, 2))" +
		" || ' '" +
		" || UPPER(SUBSTRING({2}, 1, 1))" +
		" || LOWER(SUBSTRING({2}, 2))"
	q.SelectFields = sq.AliasFields{
		FILM.FILM_ID.As("fid"),
		FILM.TITLE,
		FILM.DESCRIPTION,
		CATEGORY.NAME.As("category"),
		FILM.RENTAL_RATE.As("price"),
		FILM.LENGTH,
		FILM.RATING,
		json_array_agg(dialect, sq.Fieldf(nameExpr, ACTOR.FIRST_NAME, ACTOR.LAST_NAME)),
	}
	return q, nil
}

type SALES_BY_FILM_CATEGORY struct {
	sq.TableInfo
	CATEGORY    sq.StringField
	TOTAL_SALES sq.NumberField
}

func (_ SALES_BY_FILM_CATEGORY) View(dialect string) (sq.Query, error) {
	PAYMENT := NEW_PAYMENT(dialect, "p")
	RENTAL := NEW_RENTAL(dialect, "r")
	INVENTORY := NEW_INVENTORY(dialect, "i")
	FILM := NEW_FILM(dialect, "f")
	FILM_CATEGORY := NEW_FILM_CATEGORY(dialect, "fc")
	CATEGORY := NEW_CATEGORY(dialect, "c")
	var q sq.SelectQuery
	q.FromTable = PAYMENT
	q.JoinTables = sq.JoinTables{
		sq.Join(RENTAL, RENTAL.RENTAL_ID.Eq(PAYMENT.RENTAL_ID)),
		sq.Join(INVENTORY, INVENTORY.INVENTORY_ID.Eq(RENTAL.INVENTORY_ID)),
		sq.Join(FILM, FILM.FILM_ID.Eq(INVENTORY.FILM_ID)),
		sq.Join(FILM_CATEGORY, FILM_CATEGORY.FILM_ID.Eq(FILM.FILM_ID)),
		sq.Join(CATEGORY, CATEGORY.CATEGORY_ID.Eq(FILM_CATEGORY.CATEGORY_ID)),
	}
	q.GroupByFields = sq.Fields{CATEGORY.NAME}
	q.OrderByFields = sq.Fields{sq.Fieldf("SUM({})", PAYMENT.AMOUNT).Desc()}
	q.SelectFields = sq.AliasFields{
		CATEGORY.NAME.As("category"),
		sq.Fieldf("SUM({})", PAYMENT.AMOUNT).As("total_sales"),
	}
	return q, nil
}

type SALES_BY_STORE struct {
	sq.TableInfo
	STORE       sq.StringField
	MANAGER     sq.StringField
	TOTAL_SALES sq.NumberField
}

func (_ SALES_BY_STORE) View(dialect string) (sq.Query, error) {
	PAYMENT := NEW_PAYMENT(dialect, "p")
	RENTAL := NEW_RENTAL(dialect, "r")
	INVENTORY := NEW_INVENTORY(dialect, "i")
	STORE := NEW_STORE(dialect, "s")
	ADDRESS := NEW_ADDRESS(dialect, "a")
	CITY := NEW_CITY(dialect, "ci")
	COUNTRY := NEW_COUNTRY(dialect, "co")
	STAFF := NEW_STAFF(dialect, "m")
	var q sq.SelectQuery
	q.FromTable = PAYMENT
	q.JoinTables = sq.JoinTables{
		sq.Join(RENTAL, RENTAL.RENTAL_ID.Eq(PAYMENT.RENTAL_ID)),
		sq.Join(INVENTORY, INVENTORY.INVENTORY_ID.Eq(RENTAL.INVENTORY_ID)),
		sq.Join(STORE, STORE.STORE_ID.Eq(INVENTORY.STORE_ID)),
		sq.Join(ADDRESS, ADDRESS.ADDRESS_ID.Eq(STORE.ADDRESS_ID)),
		sq.Join(CITY, CITY.CITY_ID.Eq(ADDRESS.CITY_ID)),
		sq.Join(COUNTRY, COUNTRY.COUNTRY_ID.Eq(CITY.COUNTRY_ID)),
		sq.Join(STAFF, STAFF.STAFF_ID.Eq(STORE.MANAGER_STAFF_ID)),
	}
	q.GroupByFields = sq.Fields{
		COUNTRY.COUNTRY,
		CITY.CITY,
		STORE.STORE_ID,
		STAFF.FIRST_NAME,
		STAFF.LAST_NAME,
	}
	q.OrderByFields = sq.Fields{
		COUNTRY.COUNTRY,
		CITY.CITY,
	}
	storeExpr := "{} || ',' || {}"
	managerExpr := "{} || ' ' || {}"
	if dialect == sq.DialectMySQL {
		storeExpr = "CONCAT({}, ',', {})"
		managerExpr = "CONCAT({}, ' ', {})"
	}
	q.SelectFields = sq.AliasFields{
		sq.Fieldf(storeExpr, CITY.CITY, COUNTRY.COUNTRY).As("store"),
		sq.Fieldf(managerExpr, STAFF.FIRST_NAME, STAFF.LAST_NAME).As("manager"),
		sq.Fieldf("SUM({})", PAYMENT.AMOUNT).As("total sales"),
	}
	return q, nil
}

type STAFF_LIST struct {
	ID       sq.NumberField
	NAME     sq.StringField
	ADDRESS  sq.StringField
	ZIP_CODE sq.StringField
	PHONE    sq.StringField
	CITY     sq.StringField
	COUNTRY  sq.StringField
	SID      sq.NumberField
}

func (_ STAFF_LIST) View(dialect string) (sq.Query, error) {
	STAFF := NEW_STAFF(dialect, "s")
	ADDRESS := NEW_ADDRESS(dialect, "a")
	CITY := NEW_CITY(dialect, "ci")
	COUNTRY := NEW_COUNTRY(dialect, "co")
	var q sq.SelectQuery
	q.FromTable = STAFF
	q.JoinTables = sq.JoinTables{
		sq.Join(ADDRESS, ADDRESS.ADDRESS_ID.Eq(STAFF.ADDRESS_ID)),
		sq.Join(CITY, CITY.CITY_ID.Eq(ADDRESS.CITY_ID)),
		sq.Join(COUNTRY, COUNTRY.COUNTRY_ID.Eq(CITY.COUNTRY_ID)),
	}
	nameExpr := "{} || ' ' || {}"
	if dialect == sq.DialectMySQL {
		nameExpr = "CONCAT({}, ' ', {})"
	}
	q.SelectFields = sq.AliasFields{
		STAFF.STAFF_ID.As("id"),
		sq.Fieldf(nameExpr, STAFF.FIRST_NAME, STAFF.LAST_NAME).As("name"),
		ADDRESS.ADDRESS,
		ADDRESS.POSTAL_CODE.As("zip_code"),
		ADDRESS.PHONE,
		CITY.CITY,
		COUNTRY.COUNTRY,
		STAFF.STORE_ID.As("sid"),
	}
	return q, nil
}
